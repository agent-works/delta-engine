import { promises as fs } from 'node:fs';
import { spawn } from 'node:child_process';
import type { ComputedFileSource } from '../types.js';

/**
 * Computed File Source Processor
 *
 * Executes external command (generator) to dynamically produce context content.
 * This is the key mechanism for memory folding, knowledge injection, and
 * dynamic context adaptation.
 */

/**
 * Expand path template variables in strings
 *
 * @param template - String potentially containing variables
 * @param agentHome - Agent project directory
 * @param cwd - Current working directory
 * @returns Expanded string
 */
function expandVariables(template: string, agentHome: string, cwd: string): string {
  return template
    .replace(/\$\{AGENT_HOME\}/g, agentHome)
    .replace(/\$\{CWD\}/g, cwd);
}

/**
 * Execute generator command with timeout
 *
 * @param command - Command array [executable, ...args]
 * @param cwd - Working directory for command execution
 * @param runId - Current run ID (injected as env var)
 * @param agentHome - Agent home directory (injected as env var)
 * @param timeoutMs - Command timeout in milliseconds
 * @returns Promise that resolves when command completes successfully
 * @throws Error if command fails or times out
 */
async function executeGenerator(
  command: string[],
  cwd: string,
  runId: string,
  agentHome: string,
  timeoutMs: number
): Promise<void> {
  return new Promise<void>((resolve, reject) => {
    const [cmd, ...args] = command;

    if (!cmd) {
      reject(new Error('Command array is empty'));
      return;
    }

    // Spawn generator process
    const proc = spawn(cmd, args, {
      cwd,
      env: {
        ...process.env,
        DELTA_RUN_ID: runId,
        DELTA_AGENT_HOME: agentHome,
        DELTA_CWD: cwd,
      },
      // Capture stdout/stderr for debugging
      stdio: ['ignore', 'pipe', 'pipe'],
    });

    let stdout = '';
    let stderr = '';

    // Collect output
    if (proc.stdout) {
      proc.stdout.on('data', (data: Buffer) => {
        stdout += data.toString();
      });
    }

    if (proc.stderr) {
      proc.stderr.on('data', (data: Buffer) => {
        stderr += data.toString();
      });
    }

    // Setup timeout
    const timeout = setTimeout(() => {
      proc.kill('SIGTERM');
      reject(
        new Error(
          `Generator timeout after ${timeoutMs}ms: ${command.join(' ')}\n` +
            `stdout: ${stdout}\nstderr: ${stderr}`
        )
      );
    }, timeoutMs);

    // Handle process completion
    proc.on('exit', (code: number | null, signal: NodeJS.Signals | null) => {
      clearTimeout(timeout);

      if (signal) {
        reject(new Error(`Generator killed by signal ${signal}: ${command.join(' ')}`));
      } else if (code === 0) {
        resolve();
      } else {
        reject(
          new Error(
            `Generator exited with code ${code}: ${command.join(' ')}\n` +
              `stdout: ${stdout}\nstderr: ${stderr}`
          )
        );
      }
    });

    // Handle spawn errors
    proc.on('error', (err: Error) => {
      clearTimeout(timeout);
      reject(new Error(`Failed to spawn generator: ${command.join(' ')}: ${err.message}`));
    });
  });
}

/**
 * Process computed file source: execute generator and read output
 *
 * Workflow:
 * 1. Expand path variables in command arguments
 * 2. Execute generator command with environment variables:
 *    - DELTA_RUN_ID: Current run ID
 *    - DELTA_AGENT_HOME: Agent project directory
 *    - DELTA_CWD: Workspace directory
 * 3. Wait for command to complete (with timeout)
 * 4. Read output file generated by command
 *
 * @param source - Computed file source configuration
 * @param agentHome - Agent project directory
 * @param cwd - Current working directory
 * @param runId - Current run ID
 * @returns Generated content as string
 * @throws Error if generator fails or output file not found
 */
export async function processComputedFileSource(
  source: ComputedFileSource,
  agentHome: string,
  cwd: string,
  runId: string
): Promise<string> {
  // Expand variables in command arguments
  const expandedCommand = source.generator.command.map((arg) =>
    expandVariables(arg, agentHome, cwd)
  );

  // Execute generator
  try {
    await executeGenerator(
      expandedCommand,
      cwd,
      runId,
      agentHome,
      source.generator.timeout_ms
    );
  } catch (err: any) {
    throw new Error(
      `Generator failed for source '${source.id || 'computed_file'}': ${err.message}`
    );
  }

  // Read output file
  const expandedOutputPath = expandVariables(source.output_path, agentHome, cwd);

  try {
    return await fs.readFile(expandedOutputPath, 'utf-8');
  } catch (err: any) {
    if (err.code === 'ENOENT') {
      throw new Error(
        `Generator output file not found: ${expandedOutputPath} ` +
          `(source: ${source.id || 'computed_file'}). ` +
          `Generator command completed but did not create the expected output file.`
      );
    }
    throw new Error(
      `Failed to read generator output ${expandedOutputPath}: ${err.message}`
    );
  }
}
