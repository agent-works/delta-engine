import { z } from 'zod';

// ============================================
// Journal Event Types (Section 7)
// ============================================

// Section 7.1: Event Envelope Schema
export const EventEnvelopeSchema = z.object({
  seq: z.number().positive().int(), // Strictly monotonic increasing integer (starting from 1)
  timestamp: z.string(), // ISO 8601 UTC timestamp
  type: z.string(),
  payload: z.record(z.any()),
});

// ============================================
// Section 7.2: Core Event Payload Schemas
// ============================================

// A. Run Lifecycle Events

export const RunStartPayloadSchema = z.object({
  run_id: z.string(),
  task: z.string(),
  agent_ref: z.string(), // Path to Agent project
});

export const RunEndPayloadSchema = z.object({
  status: z.enum(['COMPLETED', 'FAILED', 'INTERRUPTED']),
});

// B. T-A-O Loop Events

export const ThoughtPayloadSchema = z.object({
  content: z.string(), // The reasoning text generated by the LLM
  llm_invocation_ref: z.string().uuid(), // Reference to io/invocations/<UUID>/
  tool_calls: z.array(z.object({
    id: z.string(),
    type: z.literal('function'),
    function: z.object({
      name: z.string(),
      arguments: z.string(),
    }),
  })).optional(), // Tool calls from LLM response
});

export const ActionRequestPayloadSchema = z.object({
  action_id: z.string(), // Tool call ID from LLM (not necessarily UUID)
  tool_name: z.string(),
  tool_args: z.record(z.any()),
  resolved_command: z.string(), // The actual command line to be executed
});

export const ActionResultPayloadSchema = z.object({
  action_id: z.string(), // Correlates back to ACTION_REQUEST
  status: z.enum(['SUCCESS', 'FAILED', 'ERROR']),
  observation_content: z.string(), // Content injected into next LLM context (may be truncated)
  execution_ref: z.string(), // Reference to io/tool_executions/<ACTION_ID>/
});

// C. User Interaction Events

export const UserMessagePayloadSchema = z.object({
  content: z.string(), // User message content (e.g., initial task)
});

// D. System & Audit Events

export const SystemMessagePayloadSchema = z.object({
  level: z.enum(['INFO', 'WARN', 'ERROR']),
  content: z.string(),
});

export const HookExecutionAuditPayloadSchema = z.object({
  hook_name: z.string(),
  status: z.enum(['SUCCESS', 'FAILED', 'SKIPPED']),
  io_path_ref: z.string(), // Relative path to io/hooks/<Step>_<HookName>/
});

// ============================================
// Discriminated Union for Journal Events
// ============================================

export const JournalEventSchema = z.discriminatedUnion('type', [
  z.object({
    seq: z.number().positive().int(),
    timestamp: z.string(),
    type: z.literal('RUN_START'),
    payload: RunStartPayloadSchema,
  }),
  z.object({
    seq: z.number().positive().int(),
    timestamp: z.string(),
    type: z.literal('RUN_END'),
    payload: RunEndPayloadSchema,
  }),
  z.object({
    seq: z.number().positive().int(),
    timestamp: z.string(),
    type: z.literal('USER_MESSAGE'),
    payload: UserMessagePayloadSchema,
  }),
  z.object({
    seq: z.number().positive().int(),
    timestamp: z.string(),
    type: z.literal('THOUGHT'),
    payload: ThoughtPayloadSchema,
  }),
  z.object({
    seq: z.number().positive().int(),
    timestamp: z.string(),
    type: z.literal('ACTION_REQUEST'),
    payload: ActionRequestPayloadSchema,
  }),
  z.object({
    seq: z.number().positive().int(),
    timestamp: z.string(),
    type: z.literal('ACTION_RESULT'),
    payload: ActionResultPayloadSchema,
  }),
  z.object({
    seq: z.number().positive().int(),
    timestamp: z.string(),
    type: z.literal('SYSTEM_MESSAGE'),
    payload: SystemMessagePayloadSchema,
  }),
  z.object({
    seq: z.number().positive().int(),
    timestamp: z.string(),
    type: z.literal('HOOK_EXECUTION_AUDIT'),
    payload: HookExecutionAuditPayloadSchema,
  }),
]);

// TypeScript Type Exports
export type JournalEvent = z.infer<typeof JournalEventSchema>;

// Individual event types for better type inference
export type RunStartEvent = Extract<JournalEvent, { type: 'RUN_START' }>;
export type RunEndEvent = Extract<JournalEvent, { type: 'RUN_END' }>;
export type UserMessageEvent = Extract<JournalEvent, { type: 'USER_MESSAGE' }>;
export type ThoughtEvent = Extract<JournalEvent, { type: 'THOUGHT' }>;
export type ActionRequestEvent = Extract<JournalEvent, { type: 'ACTION_REQUEST' }>;
export type ActionResultEvent = Extract<JournalEvent, { type: 'ACTION_RESULT' }>;
export type SystemMessageEvent = Extract<JournalEvent, { type: 'SYSTEM_MESSAGE' }>;
export type HookExecutionAuditEvent = Extract<JournalEvent, { type: 'HOOK_EXECUTION_AUDIT' }>;

// Journal Event Type Enum for convenience
export enum JournalEventType {
  RUN_START = 'RUN_START',
  RUN_END = 'RUN_END',
  USER_MESSAGE = 'USER_MESSAGE',
  THOUGHT = 'THOUGHT',
  ACTION_REQUEST = 'ACTION_REQUEST',
  ACTION_RESULT = 'ACTION_RESULT',
  SYSTEM_MESSAGE = 'SYSTEM_MESSAGE',
  HOOK_EXECUTION_AUDIT = 'HOOK_EXECUTION_AUDIT',
}

// ============================================
// Runtime I/O Types (Section 6)
// ============================================

// Section 6.2: LLM Invocation Details
export interface LLMInvocationRequest {
  messages: Array<{
    role: 'system' | 'user' | 'assistant' | 'tool';
    content: string;
    tool_call_id?: string;
    tool_calls?: Array<{
      id: string;
      type: 'function';
      function: {
        name: string;
        arguments: string;
      };
    }>;
  }>;
  model: string;
  temperature?: number;
  max_tokens?: number;
  tools?: Array<{
    type: 'function';
    function: {
      name: string;
      description?: string;
      parameters: Record<string, any>;
    };
  }>;
}

export interface LLMInvocationResponse {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: Array<{
    index: number;
    message: {
      role: string;
      content?: string;
      tool_calls?: Array<{
        id: string;
        type: 'function';
        function: {
          name: string;
          arguments: string;
        };
      }>;
    };
    finish_reason: string;
  }>;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

export interface LLMInvocationMetadata {
  model_id: string;
  duration_ms: number;
  token_usage: {
    prompt: number;
    completion: number;
    total: number;
  };
  status: 'SUCCESS' | 'FAILED' | 'TIMEOUT';
  error?: string;
}

// Section 6.3: Tool Execution Details
export interface ToolExecutionRecord {
  command: string; // The actual command line executed
  stdout: string;
  stderr: string;
  exit_code: number;
  duration_ms: number;
}

// Section 6.4: Hook Execution Details
export interface HookInputContext {
  hook_name: string;
  step_index: number;
  run_id: string;
  timestamp: string;
}

export interface HookControlOutput {
  action?: 'CONTINUE' | 'ABORT' | 'RETRY';
  message?: string;
  modifications?: Record<string, any>;
  skip?: boolean;  // For pre_tool_exec hook to skip tool execution
}

export interface HookExecutionMeta {
  command: string;
  stdout: string;
  stderr: string;
  exit_code: number;
  duration_ms: number;
}

// ============================================
// CWD Structure Types (Section 5)
// ============================================

export enum RunStatus {
  RUNNING = 'RUNNING',
  WAITING_FOR_INPUT = 'WAITING_FOR_INPUT',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  INTERRUPTED = 'INTERRUPTED'
}

export interface DeltaRunMetadata {
  run_id: string;
  start_time: string;
  end_time?: string;
  agent_ref: string;
  task: string;
  status: RunStatus;
  iterations_completed: number;
  error?: string;

  // v1.10: Process tracking fields for Janitor mechanism
  pid: number;                  // Process ID of the delta run process
  hostname: string;             // Hostname where the run started
  start_time_unix: number;      // Unix timestamp (ms) for process start time
  process_name: string;         // Process name (e.g., "node")
}

export interface WorkspaceManifest {
  schema_version: string; // e.g., "1.1"
  created_at: string;
  last_modified: string;
  description?: string;
  runs_count: number;
  latest_run_id?: string;
}