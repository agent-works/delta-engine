# Delta Engine v1.6 Context Layer - Implementation Plan

**Version**: 1.6.0
**Date**: October 7, 2025
**Status**: Implementation Plan (Draft)
**Author**: Delta Engine Team

> **Context**: This document provides a detailed implementation plan for the v1.6 Context Composition Layer described in `docs/architecture/v1.6-context-composition.md`.

---

## 1. Implementation Overview

### 1.1 Goal

Implement a declarative context composition system that enables:
- Dynamic context generation via external tools (`computed_file`)
- Workspace guide auto-loading (`DELTA.md`)
- Flexible source ordering and composition
- Zero-config operation with optional advanced customization

### 1.2 Non-Goals (Deferred to v1.6.1+)

The following features are **explicitly excluded** from v1.6.0:
- ❌ Token budget management (`total_max_tokens`, per-source `max_tokens`)
- ❌ Truncation strategies (`strategy: truncate_head`)
- ❌ Conditional loading (`condition` field)
- ❌ Caching for computed files
- ❌ Context pipelines (multi-stage processing)

**Rationale:** v1.6.0 validates the core protocol. Token management will be designed based on real-world usage data.

### 1.3 Success Metrics

- ✅ All existing agents work without modification (backward compatibility)
- ✅ `DELTA.md` files are auto-loaded when present
- ✅ `computed_file` generators can be executed and their output injected
- ✅ Custom `context.yaml` completely overrides default behavior
- ✅ Unit test coverage ≥ 85% for `src/context/` module
- ✅ Integration tests validate end-to-end context construction
- ✅ Example agent demonstrates memory folding use case

---

## 2. Scope Definition

### 2.1 What's Included in v1.6.0

#### Core Features
- ✅ `context.yaml` file format and Zod schemas
- ✅ Three source types: `file`, `computed_file`, `journal`
- ✅ Path variable expansion (`${AGENT_HOME}`, `${CWD}`)
- ✅ Error handling (`on_missing: skip | error`)
- ✅ Default context strategy (no config required)
- ✅ ContextBuilder class with source processors

#### Engine Integration
- ✅ Modify `engine.ts` to use ContextBuilder
- ✅ Remove old hardcoded context construction
- ✅ Preserve `pre_llm_req` hook compatibility

#### Testing
- ✅ Unit tests for ContextBuilder and source processors
- ✅ Integration tests for full context construction
- ✅ E2E test with example agent

#### Documentation
- ✅ Architecture design document
- ✅ Implementation plan (this document)
- ✅ Update `CLAUDE.md` with context.yaml info
- ✅ Create user guide: `docs/guides/context-management.md`
- ✅ Create example agent: `examples/memory-folding/`

### 2.2 What's Deferred to v1.6.1+

**Token Budget System** (v1.6.1 - 2-3 weeks after v1.6.0):
- Global `total_max_tokens` budget
- Per-source `max_tokens` limits
- Accounting and allocation logic
- Integration with `tiktoken` or similar

**Advanced Features** (v1.6.2+ - TBD):
- Conditional loading
- Caching and cache invalidation
- Context pipelines
- Source priority and fallback strategies

---

## 3. File Structure

### 3.1 New Files

```
src/
└── context/                          # ⭐ New module (~500 lines total)
    ├── types.ts                      # ~120 lines - Zod schemas
    ├── builder.ts                    # ~150 lines - ContextBuilder class
    ├── sources/
    │   ├── file-source.ts            # ~60 lines
    │   ├── computed-source.ts        # ~80 lines
    │   └── journal-source.ts         # ~70 lines
    └── index.ts                      # ~20 lines - Exports

tests/
├── unit/context/
│   ├── types.test.ts                 # Schema validation tests
│   ├── builder.test.ts               # ContextBuilder logic
│   └── sources/
│       ├── file-source.test.ts
│       ├── computed-source.test.ts
│       └── journal-source.test.ts
└── integration/context/
    └── context-composition.test.ts   # End-to-end tests

docs/
├── architecture/
│   └── v1.6-context-composition.md   # ✅ Created
├── implementation/
│   └── v1.6-context-layer.md         # ✅ This document
└── guides/
    └── context-management.md         # To be created

examples/
└── memory-folding/                   # New example agent
    ├── config.yaml
    ├── context.yaml                  # ⭐ Demonstrates feature
    ├── system_prompt.md
    └── tools/
        └── summarize.py              # Memory folding tool
```

### 3.2 Modified Files

```
src/
├── engine.ts                         # ~30 lines changed
│   # - Remove hardcoded context logic
│   # - Integrate ContextBuilder
│   # - Preserve pre_llm_req hook compatibility
└── types.ts                          # ~10 lines added
    # - Export ContextManifest, ContextSource types

CLAUDE.md                             # Add context.yaml section
```

---

## 4. Core Type Definitions

### 4.1 Zod Schemas (`src/context/types.ts`)

```typescript
import { z } from 'zod';

// === File Source ===
const FileSourceSchema = z.object({
  type: z.literal('file'),
  id: z.string().optional(),
  path: z.string(),
  on_missing: z.enum(['error', 'skip']).default('error'),
});

// === Computed File Source ===
const ComputedFileSourceSchema = z.object({
  type: z.literal('computed_file'),
  id: z.string().optional(),
  generator: z.object({
    command: z.array(z.string()).min(1),
    timeout_ms: z.number().positive().default(30000),
  }),
  output_path: z.string(),
  on_missing: z.enum(['error', 'skip']).default('error'),
});

// === Journal Source ===
const JournalSourceSchema = z.object({
  type: z.literal('journal'),
  id: z.string().optional(),
  max_iterations: z.number().positive().optional(),
});

// === Union Type ===
export const ContextSourceSchema = z.discriminatedUnion('type', [
  FileSourceSchema,
  ComputedFileSourceSchema,
  JournalSourceSchema,
]);

// === Manifest Schema ===
export const ContextManifestSchema = z.object({
  sources: z.array(ContextSourceSchema).min(1),
});

// === TypeScript Types ===
export type FileSource = z.infer<typeof FileSourceSchema>;
export type ComputedFileSource = z.infer<typeof ComputedFileSourceSchema>;
export type JournalSource = z.infer<typeof JournalSourceSchema>;
export type ContextSource = z.infer<typeof ContextSourceSchema>;
export type ContextManifest = z.infer<typeof ContextManifestSchema>;

// === Default Manifest ===
export const DEFAULT_MANIFEST: ContextManifest = {
  sources: [
    {
      type: 'file',
      path: '${AGENT_HOME}/system_prompt.md',
    },
    {
      type: 'file',
      path: '${CWD}/DELTA.md',
      on_missing: 'skip',
    },
    // No journal source in DEFAULT_MANIFEST!
    // Engine falls back to full conversation rebuilding (v1.5 behavior)
  ],
};
```

### 4.2 Key Design Decisions

**Discriminated union**: `type` field allows TypeScript to narrow types automatically.

```typescript
function processSource(source: ContextSource) {
  switch (source.type) {
    case 'file':
      // TypeScript knows source is FileSource here
      return processFileSource(source);
    case 'computed_file':
      // TypeScript knows source is ComputedFileSource here
      return processComputedFile(source);
    case 'journal':
      // TypeScript knows source is JournalSource here
      return processJournalSource(source);
  }
}
```

**Default manifest**: Hardcoded in TypeScript, not YAML. This ensures:
- No file I/O for default case
- No parsing errors
- Single source of truth in code

---

## 5. Implementation Details

### 5.1 ContextBuilder Class (`src/context/builder.ts`)

```typescript
import { promises as fs } from 'node:fs';
import * as path from 'node:path';
import * as yaml from 'js-yaml';
import type { Message } from './types.js';
import type { Journal } from '../journal.js';
import {
  ContextManifest,
  ContextManifestSchema,
  ContextSource,
  DEFAULT_MANIFEST,
} from './types.js';
import { processFileSource } from './sources/file-source.js';
import { processComputedFileSource } from './sources/computed-source.js';
import { processJournalSource } from './sources/journal-source.js';

export class ContextBuilder {
  constructor(
    private agentHome: string,
    private cwd: string,
    private journal: Journal
  ) {}

  /**
   * Build LLM context messages from manifest
   */
  async build(): Promise<Message[]> {
    const manifest = await this.loadManifest();
    const messages: Message[] = [];

    for (const source of manifest.sources) {
      try {
        const content = await this.processSource(source);
        if (content) {
          messages.push({
            role: 'system',
            content: this.wrapContent(source, content),
          });
        }
      } catch (err) {
        // Handle on_missing behavior
        if (this.shouldSkip(source, err)) {
          continue;
        }
        throw err;
      }
    }

    return messages;
  }

  /**
   * Load context.yaml if exists, otherwise use default
   */
  private async loadManifest(): Promise<ContextManifest> {
    const manifestPath = path.join(this.agentHome, 'context.yaml');

    try {
      const content = await fs.readFile(manifestPath, 'utf-8');
      const parsed = yaml.load(content);
      return ContextManifestSchema.parse(parsed);
    } catch (err: any) {
      if (err.code === 'ENOENT') {
        // No context.yaml - use default
        return DEFAULT_MANIFEST;
      }
      throw new Error(`Failed to parse context.yaml: ${err.message}`);
    }
  }

  /**
   * Process a single source (delegate to type-specific processors)
   */
  private async processSource(source: ContextSource): Promise<string | null> {
    switch (source.type) {
      case 'file':
        return processFileSource(source, this.agentHome, this.cwd);
      case 'computed_file':
        return processComputedFileSource(source, this.agentHome, this.cwd);
      case 'journal':
        return processJournalSource(source, this.journal);
    }
  }

  /**
   * Wrap content with source identification
   */
  private wrapContent(source: ContextSource, content: string): string {
    const id = source.id || source.type;
    return `# Context Block: ${id}\n\n${content}`;
  }

  /**
   * Check if error should be skipped based on on_missing field
   */
  private shouldSkip(source: ContextSource, err: any): boolean {
    if ('on_missing' in source && source.on_missing === 'skip') {
      return err.code === 'ENOENT'; // File not found
    }
    return false;
  }
}
```

### 5.2 File Source Processor (`src/context/sources/file-source.ts`)

```typescript
import { promises as fs } from 'node:fs';
import type { FileSource } from '../types.js';

/**
 * Expand path variables: ${AGENT_HOME}, ${CWD}
 */
function expandPath(
  pathTemplate: string,
  agentHome: string,
  cwd: string
): string {
  return pathTemplate
    .replace(/\$\{AGENT_HOME\}/g, agentHome)
    .replace(/\$\{CWD\}/g, cwd);
}

/**
 * Process file source: read and return content
 */
export async function processFileSource(
  source: FileSource,
  agentHome: string,
  cwd: string
): Promise<string> {
  const expandedPath = expandPath(source.path, agentHome, cwd);
  return await fs.readFile(expandedPath, 'utf-8');
}
```

### 5.3 Computed File Source Processor (`src/context/sources/computed-source.ts`)

```typescript
import { promises as fs } from 'node:fs';
import { spawn } from 'node:child_process';
import type { ComputedFileSource } from '../types.js';

/**
 * Execute generator command and read output
 */
export async function processComputedFileSource(
  source: ComputedFileSource,
  agentHome: string,
  cwd: string
): Promise<string> {
  // 1. Expand path variables in command
  const expandedCommand = source.generator.command.map((arg) =>
    arg
      .replace(/\$\{AGENT_HOME\}/g, agentHome)
      .replace(/\$\{CWD\}/g, cwd)
  );

  // 2. Execute generator command
  await executeGenerator(expandedCommand, cwd, source.generator.timeout_ms);

  // 3. Read output file
  const expandedOutputPath = source.output_path
    .replace(/\$\{AGENT_HOME\}/g, agentHome)
    .replace(/\$\{CWD\}/g, cwd);

  return await fs.readFile(expandedOutputPath, 'utf-8');
}

/**
 * Execute command with timeout
 */
async function executeGenerator(
  command: string[],
  cwd: string,
  timeoutMs: number
): Promise<void> {
  return new Promise((resolve, reject) => {
    const [cmd, ...args] = command;
    const proc = spawn(cmd, args, {
      cwd,
      env: {
        ...process.env,
        DELTA_AGENT_HOME: '', // Will be set by caller
        DELTA_CWD: cwd,
      },
    });

    const timeout = setTimeout(() => {
      proc.kill();
      reject(new Error(`Generator timeout after ${timeoutMs}ms`));
    }, timeoutMs);

    proc.on('exit', (code) => {
      clearTimeout(timeout);
      if (code === 0) {
        resolve();
      } else {
        reject(new Error(`Generator exited with code ${code}`));
      }
    });

    proc.on('error', (err) => {
      clearTimeout(timeout);
      reject(err);
    });
  });
}
```

### 5.4 Journal Source Processor (`src/context/sources/journal-source.ts`)

**Key difference**: Journal source returns `ChatCompletionMessageParam[]` (not `string`), providing raw OpenAI-format conversation.

```typescript
import type { JournalSource } from '../types.js';
import type { Journal } from '../../journal.js';
import type { JournalEvent } from '../../journal-types.js';
import type { ChatCompletionMessageParam } from 'openai/resources/chat/index.js';

/**
 * Reconstruct conversation from journal as OpenAI-format messages
 *
 * This is the original conversation rebuilding logic from v1.5,
 * now extracted as a configurable context source.
 */
export async function processJournalSource(
  source: JournalSource,
  journal: Journal
): Promise<ChatCompletionMessageParam[]> {  // ← Returns message array
  const allEvents = await journal.readJournal();

  // Apply max_iterations limit if specified
  const limitedEvents = source.max_iterations
    ? limitToRecentIterations(allEvents, source.max_iterations)
    : allEvents;

  // Reconstruct as OpenAI-format messages
  const messages: ChatCompletionMessageParam[] = [];

  for (const event of limitedEvents) {
    if (event.type === 'THOUGHT') {
      messages.push({
        role: 'assistant',
        content: event.payload.content || null,
        tool_calls: event.payload.tool_calls,
      });
    } else if (event.type === 'ACTION_RESULT') {
      messages.push({
        role: 'tool',
        content: event.payload.observation_content,
        tool_call_id: event.payload.action_id,
      });
    }
  }

  return messages;
}

/**
 * Limit events to recent N iterations
 *
 * An iteration = 1 THOUGHT + associated ACTION_RESULT events
 */
function limitToRecentIterations(
  events: JournalEvent[],
  maxIterations: number
): JournalEvent[] {
  // Find all THOUGHT event indices
  const thoughtIndices: number[] = [];
  events.forEach((event, index) => {
    if (event.type === 'THOUGHT') {
      thoughtIndices.push(index);
    }
  });

  // If fewer than maxIterations thoughts, return all
  if (thoughtIndices.length <= maxIterations) {
    return events;
  }

  // Take events from the (N-maxIterations)th THOUGHT onwards
  const startIndex = thoughtIndices[thoughtIndices.length - maxIterations];
  return events.slice(startIndex!);
}
  }

  return lines.join('\n');
}
```

### 5.5 Engine Integration (`src/engine.ts`)

```typescript
// BEFORE (v1.5):
private async rebuildConversationFromJournal(): Promise<Message[]> {
  const events = await this.journal.readJournal();
  const messages: Message[] = [
    { role: 'system', content: this.systemPrompt }
  ];

  // ... complex event processing logic ...

  return messages;
}

// AFTER (v1.6):
import { ContextBuilder } from './context/builder.js';

private async rebuildConversationFromJournal(): Promise<Message[]> {
  const builder = new ContextBuilder(
    this.ctx.agentHome,
    this.ctx.cwd,
    this.journal
  );

  return await builder.build();
}
```

**Key insight:** All context construction logic moves to `src/context/`. Engine becomes thin orchestrator.

---

## 6. Testing Strategy

### 6.1 Unit Tests

#### `tests/unit/context/types.test.ts`
```typescript
describe('ContextManifestSchema', () => {
  it('should validate valid manifest', () => {
    const manifest = {
      sources: [
        { type: 'file', path: 'system_prompt.md' }
      ]
    };
    expect(() => ContextManifestSchema.parse(manifest)).not.toThrow();
  });

  it('should reject invalid source type', () => {
    const manifest = {
      sources: [
        { type: 'invalid', path: 'file.md' }
      ]
    };
    expect(() => ContextManifestSchema.parse(manifest)).toThrow();
  });

  it('should apply defaults', () => {
    const manifest = {
      sources: [
        { type: 'file', path: 'file.md' }
      ]
    };
    const parsed = ContextManifestSchema.parse(manifest);
    expect(parsed.sources[0].on_missing).toBe('error');
  });
});
```

#### `tests/unit/context/builder.test.ts`
```typescript
describe('ContextBuilder', () => {
  it('should use default manifest when no context.yaml', async () => {
    const builder = new ContextBuilder('/agent', '/workspace', mockJournal);
    const messages = await builder.build();

    expect(messages).toHaveLength(3); // system_prompt + DELTA.md + journal
  });

  it('should load custom context.yaml if present', async () => {
    // Mock fs.readFile to return custom manifest
    const messages = await builder.build();
    // Assert custom sources are used
  });

  it('should skip missing files when on_missing=skip', async () => {
    // Test graceful handling of missing DELTA.md
  });

  it('should wrap content with source ID', async () => {
    const messages = await builder.build();
    expect(messages[0].content).toContain('# Context Block:');
  });
});
```

#### `tests/unit/context/sources/file-source.test.ts`
```typescript
describe('processFileSource', () => {
  it('should expand ${AGENT_HOME} variable', async () => {
    const source = { type: 'file', path: '${AGENT_HOME}/prompt.md' };
    // Mock fs.readFile
    await processFileSource(source, '/agent', '/workspace');
    // Assert fs.readFile called with '/agent/prompt.md'
  });

  it('should expand ${CWD} variable', async () => {
    const source = { type: 'file', path: '${CWD}/DELTA.md' };
    // Test CWD expansion
  });

  it('should throw on missing file when on_missing=error', async () => {
    const source = { type: 'file', path: 'missing.md', on_missing: 'error' };
    await expect(processFileSource(source, '/agent', '/workspace')).rejects.toThrow();
  });
});
```

#### `tests/unit/context/sources/computed-source.test.ts`
```typescript
describe('processComputedFileSource', () => {
  it('should execute generator command', async () => {
    const source = {
      type: 'computed_file',
      generator: { command: ['echo', 'test'] },
      output_path: '/tmp/output.txt'
    };
    // Mock spawn and fs.readFile
    const result = await processComputedFileSource(source, '/agent', '/workspace');
    expect(result).toBe('test');
  });

  it('should timeout long-running generators', async () => {
    const source = {
      type: 'computed_file',
      generator: { command: ['sleep', '100'], timeout_ms: 100 },
      output_path: '/tmp/output.txt'
    };
    await expect(processComputedFileSource(source, '/agent', '/workspace')).rejects.toThrow('timeout');
  });

  it('should pass environment variables to generator', async () => {
    // Test DELTA_CWD, DELTA_AGENT_HOME injection
  });
});
```

#### `tests/unit/context/sources/journal-source.test.ts`
```typescript
describe('processJournalSource', () => {
  it('should extract all conversation events by default', async () => {
    const mockJournal = createMockJournal([
      { type: 'THOUGHT', payload: { content: 'thinking...' } },
      { type: 'ACTION_REQUEST', payload: { tool_name: 'list_files' } },
      { type: 'ACTION_RESULT', payload: { observation_content: 'file.txt' } }
    ]);

    const result = await processJournalSource({ type: 'journal' }, mockJournal);
    expect(result).toContain('thinking...');
    expect(result).toContain('list_files');
  });

  it('should limit to max_iterations', async () => {
    const mockJournal = createMockJournal(/* 10 turns */);
    const result = await processJournalSource(
      { type: 'journal', max_iterations: 3 },
      mockJournal
    );
    // Assert only last 3 turns included
  });
});
```

### 6.2 Integration Tests

#### `tests/integration/context/context-composition.test.ts`
```typescript
describe('Context Composition Integration', () => {
  it('should build context with default manifest', async () => {
    const tempDir = await createTempWorkspace();
    // Create system_prompt.md, DELTA.md
    // Create mock journal

    const builder = new ContextBuilder(agentHome, tempDir, journal);
    const messages = await builder.build();

    expect(messages).toHaveLength(3);
    expect(messages[0].content).toContain('system prompt');
    expect(messages[1].content).toContain('workspace guide');
    expect(messages[2].content).toContain('recent conversation');
  });

  it('should execute computed_file generator', async () => {
    const tempDir = await createTempWorkspace();
    // Create context.yaml with computed_file source
    // Create a simple generator script (echo "summary")

    const messages = await builder.build();
    expect(messages.some(m => m.content.includes('summary'))).toBe(true);
  });

  it('should override default manifest with custom context.yaml', async () => {
    // Create context.yaml with only 1 source
    const messages = await builder.build();
    expect(messages).toHaveLength(1);
  });

  it('should handle missing DELTA.md gracefully', async () => {
    // Don't create DELTA.md
    const messages = await builder.build();
    // Should not throw, DELTA.md skipped
  });
});
```

### 6.3 E2E Tests

#### `tests/e2e/context-aware-agent.test.ts`
```typescript
describe('Context-Aware Agent E2E', () => {
  it('should use DELTA.md in agent decisions', async () => {
    // Create workspace with DELTA.md containing special instructions
    // Run agent with a task
    // Verify agent's actions reflect DELTA.md guidance
  });

  it('should use computed context from memory folding', async () => {
    // Create agent with custom context.yaml
    // Run agent for multiple iterations
    // Verify compressed context is used in later iterations
  });
});
```

### 6.4 Test Coverage Goals

- **Unit tests**: ≥ 85% coverage for `src/context/` module
- **Integration tests**: Cover all source type combinations
- **E2E tests**: Validate real agent workflows

---

## 7. Documentation Requirements

### 7.1 New Documents

#### `docs/guides/context-management.md`
```markdown
# Context Management Guide

## Quick Start

Delta Engine automatically loads:
- `system_prompt.md` (agent instructions)
- `DELTA.md` (workspace guide, if present)
- Recent conversation history

## Workspace Guides

Create `DELTA.md` in your workspace:
\`\`\`markdown
# Project Guide
This is a React project. Use `npm start` to run dev server.
\`\`\`

## Custom Context Strategies

Create `context.yaml` in your agent directory:
\`\`\`yaml
sources:
  - type: file
    path: "${AGENT_HOME}/system_prompt.md"
  - type: computed_file
    generator:
      command: ["python3", "tools/summarize.py"]
    output_path: "${CWD}/.delta/context_artifacts/summary.md"
\`\`\`

## Memory Folding Example
[... detailed example ...]
```

#### `docs/api/context-yaml.md`
```markdown
# context.yaml API Reference

## Schema
[... complete schema documentation ...]

## Source Types
### file
### computed_file
### journal

## Examples
[... annotated examples ...]
```

### 7.2 Updates to Existing Documents

#### `CLAUDE.md`
Add section:
```markdown
## Context Management (v1.6+)

Delta Engine builds LLM context from:
1. `system_prompt.md` (agent instructions)
2. `DELTA.md` (workspace guide, auto-loaded if present)
3. Recent conversation history from `journal.jsonl`

### Custom Context Strategies

Create `context.yaml` to define custom context sources:
\`\`\`yaml
sources:
  - type: computed_file
    generator:
      command: ["python3", "tools/summarize.py"]
    output_path: "${CWD}/.delta/context_artifacts/summary.md"
\`\`\`

See `docs/guides/context-management.md` for details.
```

#### `README.md`
Update "Key Features" section:
- Add "Flexible context composition with memory folding support"

---

## 8. Example Agents

### 8.1 New Example: Memory Folding Agent

**Location:** `examples/memory-folding/`

**Structure:**
```
examples/memory-folding/
├── config.yaml
├── context.yaml                    # ⭐ Demonstrates feature
├── system_prompt.md
├── README.md
└── tools/
    └── summarize.py                # Memory compression tool
```

**context.yaml:**
```yaml
sources:
  - type: file
    path: "${AGENT_HOME}/system_prompt.md"

  - type: computed_file
    id: compressed_memory
    generator:
      command: ["python3", "${AGENT_HOME}/tools/summarize.py"]
    output_path: "${CWD}/.delta/context_artifacts/summary.md"

  - type: journal
    max_iterations: 5  # Only recent 5 turns
```

**tools/summarize.py:**
```python
#!/usr/bin/env python3
import json
import os

def read_journal(run_id):
    journal_path = f".delta/{run_id}/journal.jsonl"
    events = []
    with open(journal_path, 'r') as f:
        for line in f:
            events.append(json.loads(line))
    return events

def extract_key_facts(events):
    """Extract important decisions and results"""
    facts = []
    for event in events:
        if event['type'] == 'THOUGHT':
            # Extract key sentences
            facts.append(event['payload']['content'][:200])
    return facts

def main():
    run_id = os.environ.get('DELTA_RUN_ID')
    if not run_id:
        # Read LATEST file
        with open('.delta/LATEST', 'r') as f:
            run_id = f.read().strip()

    events = read_journal(run_id)
    facts = extract_key_facts(events)

    # Write summary
    os.makedirs('.delta/context_artifacts', exist_ok=True)
    with open('.delta/context_artifacts/summary.md', 'w') as f:
        f.write('# Compressed Memory\n\n')
        for i, fact in enumerate(facts, 1):
            f.write(f'{i}. {fact}\n')

if __name__ == '__main__':
    main()
```

**README.md:**
```markdown
# Memory Folding Example

Demonstrates context compression using `context.yaml`.

## How It Works
1. Agent runs for multiple iterations
2. Before each LLM call, `summarize.py` compresses journal history
3. Context = system_prompt + compressed_memory + last 5 turns
4. Agent maintains long-term memory within context window limits

## Usage
\`\`\`bash
delta run --agent examples/memory-folding --task "Complex multi-step task"
\`\`\`
```

### 8.2 Update Existing Examples

**`examples/1-basics/hello-world/`:**
- Add optional `DELTA.md` to demonstrate workspace guide feature

---

## 9. Implementation Timeline

### Phase 1: Core Implementation (3-4 days)
**Day 1:**
- [ ] Create `src/context/` directory structure
- [ ] Implement `types.ts` with Zod schemas
- [ ] Implement `builder.ts` (ContextBuilder class)
- [ ] Write unit tests for types and builder

**Day 2:**
- [ ] Implement `sources/file-source.ts`
- [ ] Implement `sources/computed-source.ts`
- [ ] Implement `sources/journal-source.ts`
- [ ] Write unit tests for all source processors

**Day 3:**
- [ ] Integrate ContextBuilder into `engine.ts`
- [ ] Remove old context construction code
- [ ] Ensure `pre_llm_req` hook still works
- [ ] Write integration tests

**Day 4:**
- [ ] Fix any issues found during integration
- [ ] Run full test suite
- [ ] Measure test coverage

### Phase 2: Testing (2-3 days)
**Day 5:**
- [ ] Create E2E test with real agent
- [ ] Test with `examples/1-basics/hello-world`
- [ ] Test `DELTA.md` auto-loading
- [ ] Test custom `context.yaml`

**Day 6:**
- [ ] Create `examples/memory-folding/`
- [ ] Implement `tools/summarize.py`
- [ ] Test memory folding workflow
- [ ] Verify computed_file execution

**Day 7:**
- [ ] Edge case testing (missing files, errors, timeouts)
- [ ] Performance testing (large journal files)
- [ ] Backward compatibility verification

### Phase 3: Documentation (1-2 days)
**Day 8:**
- [ ] Write `docs/guides/context-management.md`
- [ ] Write `docs/api/context-yaml.md`
- [ ] Update `CLAUDE.md`
- [ ] Update `README.md`

**Day 9:**
- [ ] Review all documentation
- [ ] Create example agent README
- [ ] Update CHANGELOG

### Phase 4: Polish and Release (1 day)
**Day 10:**
- [ ] Final code review
- [ ] Ensure all tests pass
- [ ] Update version to 1.6.0
- [ ] Create release notes

**Total Estimated Time:** 9-10 days

---

## 10. Risk Assessment

### 10.1 Technical Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|-----------|
| Backward compatibility breaks | Low | High | Extensive testing with existing agents |
| computed_file timeout issues | Medium | Medium | Configurable timeout, clear error messages |
| Path expansion edge cases | Medium | Low | Comprehensive unit tests |
| pre_llm_req hook conflicts | Low | High | Integration test with hooks |
| Large journal files slow down processing | Medium | Medium | Defer to v1.6.1 (token budgets will address) |

### 10.2 User Experience Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|-----------|
| context.yaml syntax too complex | Low | Medium | Excellent documentation and examples |
| Users confused about default behavior | Medium | Low | Clear explanation in docs |
| Debugging computed_file failures | High | Medium | Detailed error messages, generator stdout/stderr capture |

### 10.3 Contingency Plans

**If implementation takes longer than expected:**
- Ship v1.6.0-beta with core features only
- Defer example agent to v1.6.1
- Community can start experimenting while docs are finalized

**If critical bugs are found post-release:**
- v1.6.1 hotfix within 1 week
- Rollback path: Users can remove `context.yaml` to revert to default behavior

---

## 11. Success Metrics

### 11.1 Technical Metrics

- ✅ Test coverage ≥ 85% for `src/context/` module
- ✅ All existing integration tests pass
- ✅ No performance regression (context construction < 100ms for typical agent)
- ✅ Zero breaking changes (all v1.5 agents work in v1.6)

### 11.2 User Adoption Metrics (6 weeks post-release)

- ✅ At least 3 community agents using custom `context.yaml`
- ✅ At least 1 community-contributed context tool (summarizer, retriever, etc.)
- ✅ Positive feedback on context management in GitHub issues

### 11.3 Quality Metrics

- ✅ Zero P0 bugs (crash, data loss) in first 2 weeks
- ✅ < 3 P1 bugs (incorrect behavior) in first month
- ✅ Documentation clarity rating ≥ 4.5/5 (via community survey)

---

## 12. Post-Release Plan

### 12.1 Monitoring

- Track context.yaml adoption via GitHub searches
- Monitor performance metrics in production agents
- Collect feedback on GitHub issues and discussions

### 12.2 Iteration Plan

**v1.6.1 (2-3 weeks after v1.6.0):**
- Token budget system (based on real usage data)
- Computed file caching (if performance issues emerge)
- Additional source types (if community requests)

**v1.6.2 (1-2 months after v1.6.0):**
- Conditional loading
- Context pipelines
- Advanced features based on community feedback

---

## 13. Summary

v1.6.0 introduces a **minimal, composable context system** that:
- Requires ~500 lines of new code
- Maintains full backward compatibility
- Enables unlimited extensibility through external tools
- Provides a foundation for advanced context engineering

**Core philosophy:** Ship the protocol, let the community innovate on strategies.

**Key deliverables:**
1. ✅ `src/context/` module with ContextBuilder
2. ✅ Three source types: file, computed_file, journal
3. ✅ Default manifest (zero-config operation)
4. ✅ Comprehensive tests (unit + integration + E2E)
5. ✅ Documentation and example agent

**Next step:** Begin Phase 1 implementation (Day 1).

---

**Status:** Ready for implementation approval.
**Estimated Completion:** 9-10 days from start date.
