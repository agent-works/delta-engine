这份文档是 Delta Engine 的最新架构设计规范 v1.1。它整合了 v1.0 的 MVP 基础设计、Delta Engine 宣言的核心哲学，并重点吸收了关于当前工作目录（CWD）架构的深入讨论成果。

v1.1 的核心更新在于将 CWD 确立为“环境即接口”哲学的物理载体，并对其内部结构、交互协议和执行机制进行了彻底的重新设计。本文档旨在为后续开发提供完备的指导。

---

# Delta Engine 架构设计规范 v1.1

## 1. 项目愿景与战略

### 1.1 价值北极星 (The WHY)

Delta Engine 项目的核心使命是为内部的元提示词与 AI Agent 原型科研团队打造一个高效、灵活的实验平台，旨在**根本性地加速 AI Agent 原型的研发、测试与迭代周期**。

Delta Engine 的定位是一部“科学仪器”，其首要价值在于加速科学发现的过程本身。

### 1.2 目标用户与场景 (The WHO)

- **用户画像：** 具备高阶 AI 知识的专家级研究员，精通提示词工程与 Agent 架构。
- **核心诉求：** 追求极致的灵活性、透明度和控制力，解决**原型迭代速度慢**的瓶颈。他们希望平台是一个赋能工具，而非一个束缚框架。

### 1.3 战略定位

Delta Engine 以其对极简主义和 Unix 哲学的激进坚守，占据独特的生态位。其核心竞争力源于架构哲学的纯粹性与一致性，与主流市场中日益复杂的“全家桶”式框架形成鲜明对比。

## 2. 核心哲学与设计原则

Delta Engine 的架构根植于一套紧密相连、自洽的设计哲学。

### 2.1 万物皆为命令 (Everything is a Command)

引擎自身不内置任何具体工具。所有功能，从文件操作到调用其他 Agent，都通过执行外部命令行程序来实现。这提供了无与伦比的扩展性，引擎的核心职责被精简为命令的调度者与执行者。

### 2.2 环境即接口 (The Environment is the Interface)

Agent 与环境和工具的交互接口，被高度简化为单一的核心概念——**当前工作目录 (CWD)**。CWD 不仅仅是一个存储位置，它是架构哲学的物理化身，是 Agent 之间通信的“状态总线”(State Bus) 和唯一的“API 契约”(API Contract)。

### 2.3 组合定义智能 (Composition Defines Intelligence)

系统的智能不应源于一个日益臃肿的中心引擎，而应通过将多个功能专一的“原子 Agent”组合起来而涌现。“组合优于内建”是指导所有功能开发的最高原则。

## 3. 系统架构概览

Delta Engine 采用**无状态核心（Stateless Core）**设计。引擎进程本身不保存跨周期的状态，CWD 是唯一的真相来源（Single Source of Truth）。

系统由三个主要部分组成：

1. **delta CLI：** 无状态的执行核心。
2. **Agent 项目：** 自包含的目录，定义了 Agent 的能力 (Prompt, Tools, Config)。
3. **工作目录 (CWD)：** 物理环境，包含 Agent 的工作产物和引擎的控制数据。

## 4. Agent 定义与配置

### 4.1 Agent 项目结构 (独立与自包含)

每个 Agent 都是一个可独立分发和版本控制的项目目录。

```yaml
/path/to/MySearchAgent/
├── config.yaml           # 核心配置文件: 元数据、LLM参数、工具清单、钩子定义
├── system_prompt.txt     # Agent 的系统提示词
└── tools/                # (可选) 存放该Agent 独有的自定义工具脚本或钩子脚本
    └── web_search.sh
```

### 4.2 delta 命令行接口 (CLI)

引擎通过 `delta` CLI 进行交互。核心命令是 `run`。

```yaml
delta run --agent <agent_path> \
	--task "<task_description>" \
	--work-dir <path_to_work_dir>
```

- `-work-dir`: (核心参数) 指定本次运行的工作目录 (CWD)。如果未提供，引擎会自动创建一个默认工作区。

### 4.3 config.yaml 核心规范

`config.yaml` 文件定义了 Agent 的行为、能力和扩展钩子。

```yaml
# 代理元数据
name: OrchestratorAgent
description: 一个编排代理。

# LLM 配置
llm_config:
  model_name: "gpt-4o"
  temperature: 0.2

# 生命周期钩子 (Lifecycle Hooks) (v1.1 新增)
# 允许外部命令介入引擎的核心工作流
lifecycle_hooks:
  # 示例: 在调用 LLM 前执行上下文优化脚本
  # ${AGENT_HOME} 在运行时会被替换为该 Agent 项目的绝对路径。
  pre_llm_req:
    command: ["python3", "${AGENT_HOME}/tools/context_optimizer.py"]

# 工具清单 (Tool Manifest)
# 体现了“万物皆为命令”的哲学。
tools:
  # 示例 1: 基础文件操作 (调用系统命令)
  - name: list_files
    description: "列出指定目录中的文件。路径应相对于当前工作目录。"
    command: ["ls", "-F"]
    parameters:
      - name: directory
        type: string
        default: "."
        inject_as: argument # 将此参数作为命令行末尾的参数注入

  # 示例 2: 通过标准输入 (stdin) 传递内容 (避免命令注入风险)
  - name: write_file
    description: "将指定内容写入文件。"
    command: ["tee"] # 使用 'tee' 命令可以安全地从 stdin 接收内容并写入文件
    parameters:
      - name: filename
        type: string
        inject_as: argument
      - name: content
        type: string
        inject_as: stdin # 标记此参数的内容通过 stdin 传递

  # 示例 3: 调用 Agent 自定义的工具脚本
  - name: search_web
    command: ["${AGENT_HOME}/tools/web_search.sh"]
    parameters:
      - name: query
        type: string
        inject_as: argument

  # 示例 4: Agent 编排工具 (调用 delta 自身)
  - name: run_sub_agent
    description: "执行一个子 Agent 来完成特定任务。"
    command: ["delta", "run"]
    parameters:
      - name: agent_path
        type: string
        inject_as: option # 注入为命令行选项
        option_name: "--agent"
      - name: task
        type: string
        inject_as: option
        option_name: "--task"
      - name: work_dir
        type: string
        description: "为子 Agent 分配的、相对于当前工作目录的子目录路径。"
        inject_as: option
        option_name: "--work-dir"
```

## 5. CWD 架构：状态总线 (v1.1 核心)

CWD 的设计是 Delta Engine v1.1 的核心。它实现了“环境即接口”的哲学，定义了引擎如何记录历史、管理状态以及提供扩展接口。

### 5.1 设计理念：数据平面与控制平面

CWD 被严格划分为两个领域，以实现执行过程与工作产物的解耦：

1. **数据平面 (Data Plane / Workspace)** (CWD 根目录):
    - Agent 的领域。包含所有与任务相关的产物 (Artifacts)。
    - 这个空间是可变的 (Mutable) 和持久的 (Persistent)，代表了任务的**当前状态**。
2. **控制平面 (Control Plane)** (`.delta/` 目录):
    - 引擎的领域。对 Agent 隐藏。
    - 包含了工作区如何达到当前状态的完整历史以及运行时接口。

```yaml
<CWD>/ (Workspace - 数据平面)
├── data.csv
├── report.md
└── .delta/ (Control Plane - 控制平面)
```

### 5.2 `.delta/` 顶层结构规范

```yaml
<CWD>/.delta/
├── VERSION    # [系统] 协议版本标识 (例如 "1.1")
├── runs/                 # [核心] 执行历史记录库
├── lock                  # [系统] 并发控制锁文件 (未来预留)
└── manifest.json         # [优化] 工作区自描述清单 (未来预留)
```

### 5.3 执行历史记录库 (.delta/)

`.delta/` 存储了所有使用该 CWD 的 Agent 执行的完整、独立的快照。这实现了“时间机器”功能，并支持迭代式工作流。

```yaml
.delta/
├── <RUN_ID_1>/
├── <RUN_ID_2>/
└── LATEST  # 包含最新运行 ID 的文本文件
```

- `<RUN_ID>` 格式: `<YYYYMMDD_HHMMSS>_<ShortUUID>` (例如 `20250926_120006_a1b2c3`)。

运行机制 (迭代支持)：

当 delta run 在指定的 CWD 启动时（无论是第一次还是第 N 次），引擎首先创建一个新的 <RUN_ID> 目录。Agent 进程在 CWD 根目录（Workspace）启动，它看到的是之前所有运行积累下来的文件状态，并在此基础上继续工作。

### 5.4 运行快照结构 (.delta/<RUN_ID>/)

每个 `<RUN_ID>` 目录都是单次执行的**不可变记录**，按功能划分为三个核心区域：

```yaml
.delta/<RUN_ID>/
├── execution/          # 高阶执行流与状态 (The Spine)
│   ├── journal.jsonl   # [必需] 权威执行日志 (T-A-O 循环)。
│   ├── metadata.json   # [必需] 运行摘要与状态。
│   └── engine.log      # (可选) 引擎进程的原始 stdout/stderr。
│
├── configuration/      # 输入配置快照 (Reproducibility Context)
│   ├── resolved_config.yaml
│   └── system_prompt.txt
│
└── io/         # 低阶 I/O 详情与接口边界 (The Interface Boundary)
    ├── hooks/            # 与生命周期钩子的交互详情
    ├── invocations/      # [新增] 与 LLM 的交互详情
    └── tool_executions/  # [新增] 与工具/命令的交互详情
```

### 5.4.1 Journal vs. Log 的区分

我们明确区分两种不同性质的记录：

- **journal.jsonl (执行日志):** 系统的权威记录和唯一真相来源。它是 Agent 的“工作记忆”。用于上下文重建、状态恢复。
- **engine.log (引擎日志):** 引擎进程的内部实现细节和遥测数据。用于诊断引擎自身的故障。

## 6. 运行时接口与 I/O 详情 (v1.1 核心)

`.delta/<RUN_ID>/io/` 是 CWD 的核心接口边界。它存储了引擎与所有外部系统（LLM API、操作系统命令、生命周期钩子脚本）交互的详细记录。这使得 `journal.jsonl` 可以保持简洁，同时提供了全链路的 I/O 审计能力。

### 6.1 结构概览

```bash
io/
├── invocations/      # 与 LLM 的交互
├── tool_executions/  # 与工具/命令的交互
└── hooks/            # 与生命周期钩子的交互
```

我们采用**持久化调用目录 (Persistent Invocation Directory)** 的设计。每一次外部交互都有一个独立的目录，提供极致的可调试性。

### 6.2 LLM 调用详情 (io/invocations/)

该目录存储每一次 LLM 调用的确切输入、输出和遥测数据。`journal.jsonl` 中的 `THOUGHT` 事件通过 `llm_invocation_ref` 链接到此处的记录。

```bash
io/invocations/
└── <INVOCATION_ID>/ (UUID)
    ├── request.json   # [输入] 发送给 LLM API 的最终载荷 (P_final)。
    ├── response.json  # [输出] 从 LLM API 接收的原始响应。
    └── metadata.json  # [遥测] 调用详情。
```

- **request.json：** 至关重要，它记录了经过 `pre_llm_req` 钩子处理后，LLM 实际“看到”的确切上下文。
- **metadata.json：** 包含 `model_id`, `duration_ms`, `token_usage` (prompt/completion/total), `status` 等。

### 6.3 工具执行详情 (io/tool_executions/)

`journal.jsonl` 中的 Observation 通常是经过截断或总结的。此目录保存工具执行的完整原始输出。`ACTION_RESULT` 事件通过 `execution_ref` 链接到此处的记录。我们采用标准化的执行记录结构。

```bash
io/tool_executions/
└── <ACTION_ID>/ (UUID)
    ├── command.txt     # 实际执行的命令行。
    ├── stdout.log      # 完整的标准输出流。
    ├── stderr.log      # 完整的标准错误流。
    ├── exit_code.txt   # 退出码 (例如 "0")。
    └── duration_ms.txt # 执行耗时。
```

### 6.4 生命周期钩子接口 (io/hooks/)

生命周期钩子允许外部命令介入引擎的核心工作流（例如进行上下文工程），这是引擎扩展性的主要机制。

### 6.4.1 结构与 API 契约

```bash
io/hooks/
  # 命名约定: <Step_Index>_<Hook_Name>
  └── <Step>_<HookName>/
        ├── input/              # 引擎 → 钩子
        │   ├── context.json    # [必需] 钩子触发的元数据。
        │   └── payload.dat     # 主数据载荷。
        │
        ├── output/             # 钩子 → 引擎
        │   ├── payload_override.dat # (可选) 覆盖后的主数据载荷。
        │   └── control.json    # (可选) 结构化控制指令。
        │
        └── execution_meta/     # 钩子执行遥测数据 (结构同 tool_executions)
            ├── command.txt
            ├── stdout.log
            ├── stderr.log
            ├── exit_code.txt
            └── duration_ms.txt
```

### 6.4.2 钩子执行协议

当生命周期事件触发时，引擎执行以下标准化流程：

1. **准备 (Prepare) (引擎):** 创建调用目录，将相关数据写入 `input/`。
2. **执行 (Execute) (引擎 & 钩子):**
    - 引擎执行配置的外部命令。
    - **CWD 约定：** 命令的 CWD 被设置为**工作区根目录** (`<CWD>/`)。
    - **环境注入 (通信信道)：** 引擎通过环境变量注入交互目录的绝对路径：
        
        ```bash
        export DELTA_RUN_ID=<RUN_ID>
        export DELTA_HOOK_IO_PATH=<Absolute_Path_to_Invocation_Dir/>
        ```
        
    - 钩子脚本使用 `DELTA_HOOK_IO_PATH` 变量定位其 `input/` 和 `output/` 目录进行读写。
3. **捕获 (Capture) (引擎):** 捕获命令执行细节，写入 `execution_meta/`。
4. **摄取与应用 (Ingest & Apply) (引擎):** 如果退出码为 0，引擎从 `output/` 读取结果文件并应用到其内部工作流中。

## 7. 核心数据结构：执行日志 (v1.1 核心)

`journal.jsonl` 是 Delta Engine 架构中的“脊髓”，承载着执行流、工作记忆和系统状态。采用 JSON Lines 格式。

### 7.1 事件信封 (Envelope Schema)

所有事件共享一个通用的信封结构。

```json
{
  "seq": 1,
  // [必需] 序列号。严格单调递增整数 (从1开始)，确保绝对顺序。
  "timestamp": "2025-09-26T10:35:35.123Z",
  // [必需] ISO 8601 UTC 时间戳。
  "type": "EVENT_TYPE",
  // [必需] 事件类型标识符。
  "payload": { ... }
  // [必需] 事件的具体内容。
}
```

### 7.2 核心事件载荷 (Payload Schemas)

### A. 运行生命周期事件

`RUN_START`: 记录运行的启动和初始状态。(seq: 1)

```json
{
  "type": "RUN_START",
  "payload": {
    "run_id": "<RUN_ID>",
    "task": "The initial task description.",
    "agent_ref": "/path/to/Agent"
  }
}
```

`RUN_END`: 记录运行的结束和最终状态。

```json
{
  "type": "RUN_END",
  "payload": {
    "status": "COMPLETED" // "COMPLETED", "FAILED", "INTERRUPTED"
  }
}
```

### B. T-A-O 循环事件

Thought 和 Action Request 被作为独立的事件记录，以清晰区分推理阶段和执行阶段。

`THOUGHT`: 记录 LLM 生成的思考过程。

```json
{
  "type": "THOUGHT",
  "payload": {
    "content": "The reasoning text generated by the LLM.",
    // [关键] 关联到 io/invocations/<UUID>/ 中保存的确切 LLM 输入/输出载荷。
    "llm_invocation_ref": "<UUID>"
  }
}
```

**设计考量 (`llm_invocation_ref`)**: 这个 ID 至关重要。它将 Journal 中的 Thought 事件与存储在 `io/invocations/<UUID>/` 目录（需在 CWD 规范中新增此目录）中的确切 LLM 输入/输出载荷关联起来。这使得研究员可以精确审计上下文工程钩子是如何影响 LLM 推理的，同时保持 Journal 本身的简洁性。

`ACTION_REQUEST`: 记录 LLM 请求执行的工具调用。(T-A-O 中的 "A")

```json
{
  "type": "ACTION_REQUEST",
  "payload": {
    "action_id": "<UUID>", // [关键] 用于将此请求与后续结果关联的唯一ID
    "tool_name": "list_files",
    "tool_args": { "directory": "." },
    "resolved_command": "ls -F ." // 引擎实际执行的命令行
  }
}
```

`ACTION_RESULT`: 记录工具执行的结果。(T-A-O 中的 "O" - Observation)

```json
{
  "type": "ACTION_RESULT",
  "payload": {
    "action_id": "<UUID>", // [关键] 关联回对应的 ACTION_REQUEST
    "status": "SUCCESS", // "SUCCESS", "FAILED", "ERROR"

    // [关键区分] 实际注入到下一次 LLM 上下文的内容 (可能被截断/总结)。
    // 这确保了 Journal 作为上下文重建来源的完整性。
    "observation_content": "The observation text provided to the LLM.",

    // [新增] 指向 io/tool_executions/<ACTION_ID>/ 的引用。
    "execution_ref": "<ACTION_ID>"
  }
}
```

### C. 系统与审计事件

`SYSTEM_MESSAGE`: 用于记录需要成为Agent 记忆一部分的引擎级事件。

```bash
{
  "type": "SYSTEM_MESSAGE",
  "payload": {
    "level": "WARN", // INFO, WARN, ERROR
    "content": "e.g., 'pre_llm_req hook failed, proceeding with baseline context.'"
  }
}
```

`HOOK_EXECUTION_AUDIT`: 显式记录生命周期钩子的执行情况。

```json
{
  "type": "HOOK_EXECUTION_AUDIT",
  "payload": {
    "hook_name": "pre_llm_req",
    "status": "SUCCESS", // SUCCESS | FAILED | SKIPPED
    // 提供指向 runtime_io 中具体输入输出目录的相对路径
    "io_path_ref": "io/hooks/005_pre_llm_req/"
  }
}
```

## 8. 核心机制与工作流

### 8.1 Agent 编排：零拷贝数据传递 (Zero-Copy Orchestration)

本架构通过共享工作目录实现了高效的 Agent 间协作。

1. **父 Agent 准备：** 父 Agent (R1) 在自己的 CWD 中为子 Agent (R2) 创建一个子目录（例如 `./analyst_job`），并准备输入文件。
2. **父 Agent 调用：** R1 调用 `run_sub_agent(..., work_dir="./analyst_job")`。
3. **引擎执行：** 父引擎将相对路径转换为绝对路径，启动子引擎 (R2) 进程，并将其 CWD 设置为该绝对路径。
4. **子 Agent 运行：** R2 在该 CWD 中读取输入并写入输出。其执行历史记录在 `./analyst_job/.delta/<R2_ID>/` 中。
5. **父 Agent 审查：** R1 可以立即从 `./analyst_job` 读取 R2 的产出物。

整个过程没有文件复制或序列化开销。

### 8.2 无状态执行与上下文重建

Delta Engine 的核心进程是无状态的。`journal.jsonl` 是唯一的真相来源。在每一次需要调用 LLM 之前，引擎都会从 CWD 重新读取并重建完整的对话历史。

**执行流程详解：**

1. **初始化：** `delta run` 启动，创建 `<RUN_ID>` 目录，初始化 `journal.jsonl`。
2. **上下文重建 (Read & Transform)：** 在每一轮循环开始时：
    - 引擎从磁盘**全量读取**当前的 `journal.jsonl`。
    - 引擎解析事件流，结合系统提示词，构建 LLM 所需的对话上下文。
3. **LLM 调用与执行：** (如果配置了钩子，会在此步之前执行，详见 8.3)。引擎调用 LLM，获得新的 Thought 和 Action。
4. **状态持久化 (Append)：**
    - 引擎立即将新的 T/A 事件以追加模式写入 `journal.jsonl`。
    - 引擎执行 Action。
    - 引擎将 Observation (O) 事件追加写入 `journal.jsonl`。
5. **循环：** 回到步骤 2。

**设计优势：**

- **极致的鲁棒性与可恢复性 (Resumability)：** 进程崩溃后，可以通过读取 `journal.jsonl` 完美地从崩溃点恢复执行 (断点续跑)。
- **透明度与实时调试：** 研究员可以通过 `tail -f journal.jsonl` 实时观察 Agent 的思考过程。
- **交互式干预 (Interactive Intervention)：** 研究员可以暂停引擎，手动修改 `journal.jsonl`，然后恢复运行。
- 通过 `llm_invocation_ref` 和 `io_path_ref` 实现了执行流与底层 I/O 细节的连接。

### 8.3 案例研究：pre_llm_req 上下文工程

该钩子用于在调用 LLM 前动态修改发送的上下文（例如注入 CWD 摘要或压缩历史）。

**核心原则：记忆与注意力的分离**

- **系统记忆 (journal.jsonl)：** 完整、不可变的客观事件记录 (Ground Truth)。
- **LLM 注意力 (Context Window)：** 临时的、经过处理的视图。
- **约束：** 钩子可以修改“注意力”，但绝不能导致“记忆”被重写。

**pre_llm_req 的 API 契约 (特化)**

```bash
<Step>_pre_llm_req/
├── input/
│   # [核心输入] 引擎准备发送给 LLM 的完整请求载荷 (P_base)。
│   └── proposed_payload.json
└── output/
    # [核心输出] 钩子处理后，要求引擎实际发送的载荷 (P_final) (完全覆盖策略)。
    └── final_payload.json
```

**集成工作流程 (Payload Transformer)**

1. **构建基线：** 引擎读取 `journal.jsonl` 并构建 P_base。
2. **钩子准备：** 将 P_base 写入 `input/proposed_payload.json`。
3. **钩子执行：** 执行外部钩子命令 (CWD=Workspace)。钩子执行转换逻辑 (注入摘要或压缩历史)，并将 P_final 写入 `output/final_payload.json`。
4. **载荷决策：** 如果钩子成功，采用 P_final；否则，回退使用 P_base。
5. **LLM 调用：** 使用最终选定的载荷调用 LLM。

可审计性：

该设计提供了极致的可审计性。通过对比 input/ 和 output/ 中的载荷，研究员可以精确地理解钩子做了什么修改。

## 9. 局限性与未来演进

### 9.1 架构权衡与风险

- **性能边界：** 此架构在处理基于文件和批处理的任务流时表现卓越。但对于需要高频、低延迟、流式交互的场景，其基于进程启动和文件 I/O 的模式可能不是最优解。
- **安全风险与沙箱：** “万物皆为命令”的灵活性带来了安全风险。开发一个强大的安全沙箱执行环境是项目的最高优先级任务。
- **用户技能要求：** 本设计要求用户对命令行、文件系统概念有深入的理解，这是为了服务于专家用户而做出的有意权衡。

### 9.2 未来演进方向

项目的未来演进将严格遵循“保持核心纯粹”的原则，采用分层演进策略：

1. **CWD 协议演进：** 探索 CWD Schemas (目录结构规范化)、自描述 CWD（通过 `.delta/manifest.json` 加速 Agent 环境感知）和事务性操作工具（如 `atomic_write_file`），以增强 CWD 作为状态总线的健壮性和表达力。
2. **用户空间扩展：** 将安全沙箱、高级监控、可视化调试界面等复杂功能，作为核心引擎之上的可选插件进行分层演进。
3. **生态系统构建：** 探索将 Agent 作为 NPM 包进行管理和分发（利用 Node.js 引擎的战略优势），以解决版本锁定与依赖管理问题，保障实验的可复现性。