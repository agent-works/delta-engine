# Delta Engine v1.10 Implementation Plan

**Version**: 1.10.0
**Date**: October 14, 2025
**Status**: Ready for Implementation
**Estimated Duration**: 10-13 days
**Author**: Delta Engine Architecture Team

---

## 1. Implementation Overview

This document provides a detailed, phase-by-phase implementation plan for Delta Engine v1.10 (Frontierless Workspace). The plan is designed for incremental delivery with continuous testing and validation.

### 1.1 Key Changes Summary

**Removed**:
- `.delta/LATEST` file and all associated logic
- Implicit `delta continue` (without `--run-id`)
- `--format none` option

**Added**:
- Client-generated Run ID support (`--run-id` parameter)
- Janitor mechanism (PID-based safe recovery)
- Three output formats: `text` (default), `json`, `raw`
- `delta list-runs` auxiliary command
- RunResult v2.0 Schema
- Enhanced metadata (PID, hostname, start_time, process_name)

**Modified**:
- CLI behavior (explicit-only resumption)
- Output formatting (stderr/stdout separation)
- Control plane structure (flat `.delta/` directory)

### 1.2 Implementation Principles

1. **Incremental Delivery**: Each phase delivers testable, working functionality
2. **Backward Compatibility First**: Preserve existing functionality until replacements are ready
3. **Test-Driven**: Write tests alongside (or before) implementation
4. **Minimal Risk**: Keep master branch deployable at each commit

---

## 2. Phase Breakdown

### Phase 1: Type Definitions & Schema (Days 1-2)

**Goal**: Establish all type definitions and schemas required for v1.10.

**Duration**: 1.5-2 days

**Dependencies**: None (can start immediately)

**Tasks**:

#### 2.1.1 Update `src/types.ts`

**Add RunResult v2.0 Schema**:
```typescript
// New schema for structured output (--format json)
export const RunResultSchema = z.object({
  schema_version: z.literal('2.0'),
  run_id: z.string(),
  status: z.enum(['COMPLETED', 'FAILED', 'WAITING_FOR_INPUT', 'INTERRUPTED']),

  // Conditional fields (mutually exclusive based on status)
  result: z.union([z.string(), z.record(z.any())]).optional(),
  error: z.object({
    type: z.string(),
    message: z.string(),
    details: z.string().optional(),
  }).optional(),
  interaction: z.object({
    prompt: z.string(),
    input_type: z.enum(['text', 'password', 'confirmation']),
    sensitive: z.boolean(),
  }).optional(),

  metrics: z.object({
    iterations: z.number(),
    duration_ms: z.number(),
    start_time: z.string(),
    end_time: z.string(),
    usage: z.object({
      total_cost_usd: z.number(),
      input_tokens: z.number(),
      output_tokens: z.number(),
      model_usage: z.record(z.any()),
    }),
  }),

  metadata: z.object({
    agent_name: z.string(),
    workspace_path: z.string(),
  }),
});

export type RunResult = z.infer<typeof RunResultSchema>;
```

**Add Output Format Enum**:
```typescript
export enum OutputFormat {
  Text = 'text',
  Json = 'json',
  Raw = 'raw',
}
```

**Add CLI Option Types**:
```typescript
export interface RunCommandOptions {
  agent: string;
  message: string;
  workDir?: string;
  maxIterations?: number;
  verbose?: boolean;
  interactive?: boolean;
  yes?: boolean;
  runId?: string;        // [New] Client-generated run ID
  format?: OutputFormat; // [New] Output format
}

export interface ContinueCommandOptions {
  workDir: string;
  runId: string;         // [Changed] Now required
  message?: string;
  verbose?: boolean;
  interactive?: boolean;
  force?: boolean;       // [New] Force continue (skip cross-host check)
  format?: OutputFormat; // [New] Output format
}

export interface ListRunsOptions {
  workDir?: string;
  resumable?: boolean;
  status?: string;
  first?: boolean;
  format?: OutputFormat;
}
```

#### 2.1.2 Update `src/journal-types.ts`

**Extend RunMetadata with new fields**:
```typescript
export interface RunMetadata {
  run_id: string;
  status: RunStatus;
  start_time: string;
  end_time?: string;
  iterations_completed: number;

  // [New v1.10] Process tracking fields
  pid: number;
  hostname: string;
  start_time_unix: number;  // Unix timestamp for process start time
  process_name: string;     // e.g., "node"

  // Existing fields...
  agent_name?: string;
  agent_version?: string;
  initial_task?: string;
  // ...
}
```

**Success Criteria**:
- [ ] All new schemas pass Zod validation
- [ ] TypeScript compilation succeeds
- [ ] No breaking changes to existing types

---

### Phase 2: Core Infrastructure (Days 2-4)

**Goal**: Implement Janitor mechanism, PID tracking, and remove LATEST dependency.

**Duration**: 2-3 days

**Dependencies**: Phase 1 complete

**Tasks**:

#### 2.2.1 Create `src/janitor.ts` (New File)

**Janitor Implementation**:
```typescript
import { promises as fs } from 'node:fs';
import path from 'node:path';
import os from 'node:os';
import { RunMetadata } from './journal-types.js';
import { RunStatus } from './journal-types.js';

export interface JanitorResult {
  wasRunning: boolean;
  cleaned: boolean;
  reason?: string;
}

/**
 * Check if a process is alive
 */
async function isProcessAlive(pid: number): Promise<boolean> {
  try {
    process.kill(pid, 0); // Signal 0 checks existence without killing
    return true;
  } catch (err: any) {
    if (err.code === 'ESRCH') {
      return false; // Process does not exist
    }
    throw err; // Other errors (e.g., permission denied)
  }
}

/**
 * Get process name from PID (Unix-like systems)
 */
async function getProcessName(pid: number): Promise<string> {
  if (process.platform === 'darwin' || process.platform === 'linux') {
    try {
      const { execSync } = await import('node:child_process');
      const result = execSync(`ps -p ${pid} -o comm=`, { encoding: 'utf-8' });
      return result.trim();
    } catch {
      return '';
    }
  }
  // Windows or other platforms - skip process name check
  return 'unknown';
}

/**
 * Janitor mechanism: Clean up orphaned RUNNING runs
 *
 * @param metadata - Run metadata to check
 * @param force - Skip cross-host check (user explicitly confirmed)
 * @returns JanitorResult indicating if cleanup was performed
 */
export async function janitorCheck(
  metadata: RunMetadata,
  force: boolean = false
): Promise<JanitorResult> {
  if (metadata.status !== RunStatus.RUNNING) {
    return { wasRunning: false, cleaned: false };
  }

  // Step 1: Cross-host detection
  const currentHostname = os.hostname();
  if (metadata.hostname !== currentHostname && !force) {
    throw new Error(
      `Run ${metadata.run_id} was started on host '${metadata.hostname}'. ` +
      `Cannot verify process status from host '${currentHostname}'. ` +
      `If you're sure the original process is dead, use --force.`
    );
  }

  // Step 2: PID liveness check
  const isAlive = await isProcessAlive(metadata.pid);

  if (!isAlive) {
    // Process is dead, safe to clean up
    return {
      wasRunning: true,
      cleaned: true,
      reason: `Process ${metadata.pid} no longer exists`
    };
  }

  // Step 3: Process name verification (prevent PID reuse false positive)
  const processName = await getProcessName(metadata.pid);
  if (processName && !processName.includes('node') && !processName.includes('delta')) {
    // PID was reused by a different process
    return {
      wasRunning: true,
      cleaned: true,
      reason: `PID ${metadata.pid} reused by different process (${processName})`
    };
  }

  // Process is still alive and matches expected name
  throw new Error(
    `Run ${metadata.run_id} is still active (PID ${metadata.pid}). ` +
    `Cannot continue while original process is running.`
  );
}

/**
 * Apply Janitor cleanup to metadata
 */
export function applyJanitorCleanup(metadata: RunMetadata): RunMetadata {
  return {
    ...metadata,
    status: RunStatus.INTERRUPTED,
  };
}
```

**Success Criteria**:
- [ ] Janitor correctly detects dead processes
- [ ] Janitor detects PID reuse scenarios
- [ ] Cross-host detection works
- [ ] Unit tests pass (see Phase 5)

#### 2.2.2 Update `src/journal.ts`

**Add PID tracking to metadata initialization**:
```typescript
async initializeMetadata(agentPath: string, task: string): Promise<void> {
  // Get current process info
  const pid = process.pid;
  const hostname = os.hostname();
  const startTimeUnix = Date.now();
  const processName = path.basename(process.argv[0] || 'node');

  const metadata: RunMetadata = {
    run_id: this.runId,
    status: RunStatus.RUNNING,
    start_time: new Date().toISOString(),
    iterations_completed: 0,

    // [New] Process tracking
    pid,
    hostname,
    start_time_unix: startTimeUnix,
    process_name: processName,

    // Existing fields...
  };

  await this.updateMetadata(metadata);
}
```

**Success Criteria**:
- [ ] PID, hostname, start_time_unix are correctly recorded
- [ ] Existing functionality unaffected

#### 2.2.3 Update `src/context.ts` - Remove LATEST Dependency

**Remove LATEST creation**:
```diff
- // Create LATEST file containing the run ID
- const latestFile = path.join(deltaDir, 'LATEST');
- await fs.writeFile(latestFile, runId, 'utf-8');
```

**Update `checkForResumableRun` (remove LATEST logic)**:
```typescript
export async function checkForResumableRun(workDir: string): Promise<string | null> {
  const deltaDir = path.join(workDir, '.delta');

  try {
    await fs.access(deltaDir);
  } catch {
    return null;
  }

  // Scan all run directories
  const runs = await fs.readdir(deltaDir);
  const validRuns = runs.filter(r => r !== 'VERSION' && !r.startsWith('.')).sort();

  if (validRuns.length === 0) {
    return null;
  }

  // Find resumable runs (INTERRUPTED, WAITING_FOR_INPUT)
  const resumableRuns: Array<{ runDir: string; metadata: RunMetadata }> = [];

  for (const runDir of validRuns) {
    try {
      const metadataPath = path.join(deltaDir, runDir, 'metadata.json');
      const metadataContent = await fs.readFile(metadataPath, 'utf-8');
      const metadata = JSON.parse(metadataContent) as RunMetadata;

      if (
        metadata.status === RunStatus.INTERRUPTED ||
        metadata.status === RunStatus.WAITING_FOR_INPUT
      ) {
        resumableRuns.push({ runDir, metadata });
      }
    } catch {
      // Skip invalid runs
    }
  }

  if (resumableRuns.length === 0) {
    return null;
  }

  // Return the most recent resumable run
  const sorted = resumableRuns.sort((a, b) =>
    b.metadata.start_time.localeCompare(a.metadata.start_time)
  );
  return sorted[0]?.runDir || null;
}
```

**Update `checkForAnyRun` (remove LATEST logic)**:
```typescript
export async function checkForAnyRun(
  workDir: string
): Promise<{ runDir: string; status: RunStatus } | null> {
  const deltaDir = path.join(workDir, '.delta');

  try {
    await fs.access(deltaDir);
  } catch {
    return null;
  }

  // Scan all run directories
  const runs = await fs.readdir(deltaDir);
  const validRuns = runs.filter(r => r !== 'VERSION' && !r.startsWith('.')).sort();

  if (validRuns.length === 0) {
    return null;
  }

  // Find the most recent run by directory name (timestamp-based)
  const latestRunDir = validRuns[validRuns.length - 1];
  if (!latestRunDir) {
    return null;
  }

  const metadataPath = path.join(deltaDir, latestRunDir, 'metadata.json');
  const metadataContent = await fs.readFile(metadataPath, 'utf-8');
  const metadata = JSON.parse(metadataContent) as RunMetadata;

  return {
    runDir: latestRunDir,
    status: metadata.status,
  };
}
```

**Update `resumeContext` (remove LATEST update, add Janitor)**:
```typescript
import { janitorCheck, applyJanitorCleanup } from './janitor.js';

export async function resumeContext(
  workDir: string,
  runDir: string,
  isInteractive?: boolean,
  newMessage?: string,
  force?: boolean
): Promise<EngineContext> {
  const deltaDir = path.join(workDir, '.delta');
  const runPath = path.join(deltaDir, runDir);

  // Read metadata
  const metadataPath = path.join(runPath, 'metadata.json');
  const metadataContent = await fs.readFile(metadataPath, 'utf-8');
  let metadata = JSON.parse(metadataContent) as RunMetadata;

  // [New] Janitor check if run is RUNNING
  if (metadata.status === RunStatus.RUNNING) {
    const janitorResult = await janitorCheck(metadata, force || false);

    if (janitorResult.cleaned) {
      console.log(`[Janitor] Cleaned up orphaned run: ${janitorResult.reason}`);
      metadata = applyJanitorCleanup(metadata);

      // Persist cleaned metadata
      await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2), 'utf-8');
    }
  }

  // [Removed] Update LATEST file logic
  // const latestFile = path.join(deltaDir, 'LATEST');
  // await fs.writeFile(latestFile, metadata.run_id, 'utf-8');

  // Continue with existing resume logic...
}
```

**Success Criteria**:
- [ ] LATEST file is never created or read
- [ ] Janitor is invoked during resume
- [ ] All E2E tests pass with LATEST removed

---

### Phase 3: CLI Enhancements (Days 5-6)

**Goal**: Update CLI to support --run-id, --format, --force, and add list-runs command.

**Duration**: 2 days

**Dependencies**: Phase 2 complete

**Tasks**:

#### 2.3.1 Update `src/cli.ts` - Add New Options

**Update `handleRunCommand`**:
```typescript
async function handleRunCommand(options: {
  agent: string;
  message: string;
  workDir?: string;
  maxIterations?: number;
  verbose?: boolean;
  interactive?: boolean;
  yes?: boolean;
  runId?: string;        // [New]
  format?: string;       // [New]
}) {
  // [New] Validate and normalize format
  const outputFormat = validateOutputFormat(options.format);

  // [New] Client-generated run ID validation
  if (options.runId) {
    // Check for run ID conflicts before initialization
    if (options.workDir) {
      const deltaDir = path.join(options.workDir, '.delta');
      const runPath = path.join(deltaDir, options.runId);

      try {
        await fs.access(runPath);
        logger.error(`Run ID "${options.runId}" already exists in workspace.`);
        logger.info('Please use a different run ID or omit --run-id for auto-generation.');
        process.exit(1);
      } catch {
        // Good, run ID is unique
      }
    }
  }

  // Continue with existing logic, passing runId to initializeContext...
  context = await initializeContext(
    options.agent,
    options.message,
    options.workDir,
    options.interactive,
    options.maxIterations,
    false,
    options.yes,
    options.runId  // [New] Pass client-generated ID
  );

  // Execute engine...
  await runEngineWithLogging(context, {
    verbose: options.verbose,
    format: outputFormat  // [New] Pass format
  });
}
```

**Update `handleContinueCommand`**:
```typescript
async function handleContinueCommand(options: {
  workDir: string;
  runId: string;         // [Changed] Now required
  message?: string;
  verbose?: boolean;
  interactive?: boolean;
  force?: boolean;       // [New]
  format?: string;       // [New]
}) {
  // [New] Validate run ID existence
  const deltaDir = path.join(options.workDir, '.delta');
  const runPath = path.join(deltaDir, options.runId);

  try {
    await fs.access(runPath);
  } catch {
    logger.error(`Run ID "${options.runId}" not found in workspace.`);
    logger.info('');
    logger.info('To list available runs:');
    logger.info(`  delta list-runs -w ${options.workDir}`);
    process.exit(1);
  }

  // [New] Validate format
  const outputFormat = validateOutputFormat(options.format);

  // Load metadata and perform Janitor check
  const context = await resumeContext(
    options.workDir,
    options.runId,
    options.interactive,
    options.message,
    options.force  // [New] Pass force flag
  );

  // Execute engine...
  await runEngineWithLogging(context, {
    verbose: options.verbose,
    format: outputFormat
  });
}
```

**Update CLI option definitions**:
```typescript
program
  .command('run')
  .description('Execute an AI agent with a specified task')
  .option(/*... existing options ...*/)
  .option(
    '--run-id <id>',
    'Client-generated run ID (must be unique within workspace)'
  )
  .option(
    '--format <format>',
    'Output format: text (default), json, raw',
    'text'
  )
  .action(handleRunCommand);

program
  .command('continue')
  .description('Resume or extend an existing run')
  .requiredOption(
    '--run-id <id>',
    'Run ID to continue (required)'
  )
  .option(/*... existing options ...*/)
  .option(
    '--force',
    'Force continue (skip cross-host process check)',
    false
  )
  .option(
    '--format <format>',
    'Output format: text (default), json, raw',
    'text'
  )
  .action(handleContinueCommand);
```

**Success Criteria**:
- [ ] --run-id is accepted and validated
- [ ] --format is parsed correctly
- [ ] --force is passed to Janitor
- [ ] Error messages guide users to list-runs

#### 2.3.2 Create `src/commands/list-runs.ts` (New File)

**Implement list-runs command**:
```typescript
import { promises as fs } from 'node:fs';
import path from 'node:path';
import { RunMetadata, RunStatus } from '../journal-types.js';

export interface ListRunsOptions {
  workDir: string;
  resumable?: boolean;
  status?: RunStatus;
  first?: boolean;
  format?: 'text' | 'json';
}

export interface RunInfo {
  run_id: string;
  status: RunStatus;
  task_summary: string;
  last_updated: string;
}

export async function listRuns(options: ListRunsOptions): Promise<RunInfo[]> {
  const deltaDir = path.join(options.workDir, '.delta');

  try {
    await fs.access(deltaDir);
  } catch {
    return [];
  }

  const runs = await fs.readdir(deltaDir);
  const validRuns = runs.filter(r => r !== 'VERSION' && !r.startsWith('.'));

  const runInfos: RunInfo[] = [];

  for (const runDir of validRuns) {
    try {
      const metadataPath = path.join(deltaDir, runDir, 'metadata.json');
      const metadataContent = await fs.readFile(metadataPath, 'utf-8');
      const metadata: RunMetadata = JSON.parse(metadataContent);

      // Apply filters
      if (options.resumable) {
        const resumableStatuses = [
          RunStatus.INTERRUPTED,
          RunStatus.WAITING_FOR_INPUT,
          RunStatus.FAILED,
          RunStatus.COMPLETED
        ];
        if (!resumableStatuses.includes(metadata.status)) {
          continue;
        }
      }

      if (options.status && metadata.status !== options.status) {
        continue;
      }

      runInfos.push({
        run_id: metadata.run_id,
        status: metadata.status,
        task_summary: metadata.initial_task || 'N/A',
        last_updated: metadata.end_time || metadata.start_time,
      });
    } catch {
      // Skip invalid runs
    }
  }

  // Sort by last_updated (most recent first)
  runInfos.sort((a, b) => b.last_updated.localeCompare(a.last_updated));

  if (options.first && runInfos.length > 0) {
    return [runInfos[0]!];
  }

  return runInfos;
}

export function formatRunList(runs: RunInfo[], format: 'text' | 'json'): string {
  if (format === 'json') {
    return JSON.stringify(runs, null, 2);
  }

  // Text format
  if (runs.length === 0) {
    return 'No runs found.';
  }

  const lines: string[] = [];
  for (const run of runs) {
    const ago = timeAgo(new Date(run.last_updated));
    const taskPreview = run.task_summary.length > 40
      ? run.task_summary.substring(0, 37) + '...'
      : run.task_summary;
    lines.push(`${run.run_id}  ${run.status.padEnd(20)}  "${taskPreview}"  ${ago}`);
  }

  return lines.join('\n');
}

function timeAgo(date: Date): string {
  const seconds = Math.floor((Date.now() - date.getTime()) / 1000);
  if (seconds < 60) return `${seconds}s ago`;
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes}m ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours}h ago`;
  const days = Math.floor(hours / 24);
  return `${days}d ago`;
}

export async function handleListRunsCommand(options: ListRunsOptions): Promise<void> {
  const workDir = options.workDir || process.cwd();
  const format = options.format || 'text';

  const runs = await listRuns({ ...options, workDir });
  const output = formatRunList(runs, format);

  console.log(output);
}
```

**Add to CLI program**:
```typescript
program
  .command('list-runs')
  .description('List runs in a workspace')
  .option('-w, --work-dir <path>', 'Work directory path', process.cwd())
  .option('--resumable', 'Show only resumable runs', false)
  .option('--status <status>', 'Filter by status (COMPLETED, FAILED, etc.)')
  .option('--first', 'Show only the most recent run', false)
  .option('--format <format>', 'Output format: text (default) or json', 'text')
  .action(handleListRunsCommand);
```

**Success Criteria**:
- [ ] list-runs lists all runs correctly
- [ ] --resumable filter works
- [ ] --first returns only one run
- [ ] --format json outputs valid JSON
- [ ] Text format is human-readable

---

### Phase 4: Output Formatting (Days 7-8)

**Goal**: Implement structured output formats (text, json, raw).

**Duration**: 1.5-2 days

**Dependencies**: Phases 1-3 complete

**Tasks**:

#### 2.4.1 Create `src/output-formatter.ts` (New File)

**Implement output formatting logic**:
```typescript
import { RunMetadata, RunStatus } from './journal-types.js';
import { OutputFormat, RunResult } from './types.js';

/**
 * Build RunResult v2.0 object from metadata
 */
export function buildRunResult(
  metadata: RunMetadata,
  finalResponse: string | Record<string, any> | null,
  error: { type: string; message: string; details?: string } | null,
  interaction: { prompt: string; input_type: string; sensitive: boolean } | null,
  agentName: string,
  workspacePath: string
): RunResult {
  // Calculate metrics
  const startTime = new Date(metadata.start_time);
  const endTime = metadata.end_time ? new Date(metadata.end_time) : new Date();
  const durationMs = endTime.getTime() - startTime.getTime();

  const result: RunResult = {
    schema_version: '2.0',
    run_id: metadata.run_id,
    status: metadata.status as any,

    metrics: {
      iterations: metadata.iterations_completed,
      duration_ms: durationMs,
      start_time: metadata.start_time,
      end_time: metadata.end_time || new Date().toISOString(),
      usage: {
        total_cost_usd: 0,  // TODO: Calculate from token usage
        input_tokens: 0,
        output_tokens: 0,
        model_usage: {},
      },
    },

    metadata: {
      agent_name: agentName,
      workspace_path: workspacePath,
    },
  };

  // Add conditional fields based on status
  if (metadata.status === RunStatus.COMPLETED && finalResponse !== null) {
    result.result = finalResponse;
  } else if (
    (metadata.status === RunStatus.FAILED || metadata.status === RunStatus.INTERRUPTED) &&
    error !== null
  ) {
    result.error = error;
  } else if (metadata.status === RunStatus.WAITING_FOR_INPUT && interaction !== null) {
    result.interaction = interaction;
  }

  return result;
}

/**
 * Format output based on format type
 */
export function formatOutput(
  format: OutputFormat,
  runResult: RunResult
): string {
  switch (format) {
    case OutputFormat.Json:
      return JSON.stringify(runResult, null, 2);

    case OutputFormat.Text:
      return formatTextSummary(runResult);

    case OutputFormat.Raw:
      return formatRawOutput(runResult);

    default:
      throw new Error(`Unknown output format: ${format}`);
  }
}

/**
 * Format text summary (human-readable)
 */
function formatTextSummary(runResult: RunResult): string {
  const lines: string[] = [];

  lines.push('--- Run Summary ---');
  lines.push(`Run ID:     ${runResult.run_id}`);
  lines.push(`Status:     ${runResult.status}`);
  lines.push(`Duration:   ${formatDuration(runResult.metrics.duration_ms)}`);
  lines.push('-------------------');

  if (runResult.result !== undefined) {
    lines.push('Result:');
    if (typeof runResult.result === 'string') {
      lines.push(runResult.result);
    } else {
      lines.push(JSON.stringify(runResult.result, null, 2));
    }
  } else if (runResult.error) {
    lines.push(`Error: ${runResult.error.message}`);
    if (runResult.error.details) {
      lines.push(`Details: ${runResult.error.details}`);
    }
  } else if (runResult.interaction) {
    lines.push(`Waiting for input: ${runResult.interaction.prompt}`);
  }

  lines.push('-------------------');
  return lines.join('\n');
}

/**
 * Format raw output (pure data for Unix pipes)
 */
function formatRawOutput(runResult: RunResult): string {
  // Only output data on COMPLETED
  if (runResult.status === 'COMPLETED' && runResult.result !== undefined) {
    if (typeof runResult.result === 'string') {
      return runResult.result;
    } else {
      return JSON.stringify(runResult.result); // Compact JSON
    }
  }

  // All other statuses: empty stdout
  return '';
}

function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  if (seconds < 60) return `${seconds}s`;
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds}s`;
}
```

**Success Criteria**:
- [ ] RunResult v2.0 is correctly constructed
- [ ] Text format is human-readable
- [ ] JSON format is valid and parseable
- [ ] Raw format outputs pure data

#### 2.4.2 Update `src/cli.ts` - Integrate Output Formatting

**Update `runEngineWithLogging`**:
```typescript
async function runEngineWithLogging(
  context: EngineContext,
  options: { verbose?: boolean; format?: OutputFormat }
): Promise<void> {
  const format = options.format || OutputFormat.Text;

  // Run engine (stderr output continues normally)
  const engine = new Engine(context);
  await engine.initialize();

  try {
    const finalResponse = await engine.run();
    const journal = engine.getJournal();
    const metadata = await journal.readMetadata();

    // Build RunResult
    const runResult = buildRunResult(
      metadata,
      finalResponse,
      null,  // no error
      null,  // no interaction
      context.config.name,
      context.workDir
    );

    // Format and output to stdout
    const output = formatOutput(format, runResult);
    console.log(output);

    // Exit with success
    process.exit(0);

  } catch (error) {
    const journal = engine.getJournal();
    const metadata = await journal.readMetadata();

    // Build error RunResult
    const runResult = buildRunResult(
      metadata,
      null,  // no result
      {
        type: 'EngineError',
        message: error instanceof Error ? error.message : String(error),
        details: error instanceof Error ? error.stack : undefined,
      },
      null,  // no interaction
      context.config.name,
      context.workDir
    );

    // Format and output to stdout
    const output = formatOutput(format, runResult);
    console.log(output);

    // Exit with failure
    process.exit(1);
  }
}
```

**Success Criteria**:
- [ ] Stdout contains only formatted output
- [ ] Stderr contains process logs
- [ ] Exit codes are correct (0=success, 1=failure, etc.)

---

### Phase 5: Testing (Days 9-11)

**Goal**: Comprehensive test coverage for all v1.10 features.

**Duration**: 3-4 days

**Dependencies**: Phases 1-4 complete

**Tasks**:

#### 2.5.1 Unit Tests

**Create `tests/unit/janitor.test.ts`**:
```typescript
describe('Janitor Mechanism', () => {
  it('should detect dead process', async () => {
    const metadata: RunMetadata = {
      run_id: 'test-001',
      status: RunStatus.RUNNING,
      pid: 99999,  // Non-existent PID
      hostname: os.hostname(),
      // ...
    };

    const result = await janitorCheck(metadata);
    expect(result.cleaned).toBe(true);
    expect(result.reason).toContain('no longer exists');
  });

  it('should reject cross-host continue without --force', async () => {
    const metadata: RunMetadata = {
      // ...
      hostname: 'other-host',
    };

    await expect(janitorCheck(metadata)).rejects.toThrow('different host');
  });

  it('should allow cross-host continue with --force', async () => {
    const metadata: RunMetadata = {
      // ...
      pid: 99999,  // Dead process
      hostname: 'other-host',
    };

    const result = await janitorCheck(metadata, true);  // force=true
    expect(result.cleaned).toBe(true);
  });
});
```

**Create `tests/unit/output-formatter.test.ts`**:
```typescript
describe('Output Formatter', () => {
  it('should format text output with summary', () => {
    const runResult: RunResult = {
      // ...
      status: 'COMPLETED',
      result: 'Task completed successfully',
    };

    const output = formatOutput(OutputFormat.Text, runResult);
    expect(output).toContain('--- Run Summary ---');
    expect(output).toContain('Status:     COMPLETED');
  });

  it('should format JSON output', () => {
    const runResult: RunResult = { /* ... */ };
    const output = formatOutput(OutputFormat.Json, runResult);

    const parsed = JSON.parse(output);
    expect(parsed.schema_version).toBe('2.0');
  });

  it('should format raw output with pure data', () => {
    const runResult: RunResult = {
      // ...
      status: 'COMPLETED',
      result: 'Pure result string',
    };

    const output = formatOutput(OutputFormat.Raw, runResult);
    expect(output).toBe('Pure result string');
    expect(output).not.toContain('Run Summary');
  });
});
```

**Create `tests/unit/list-runs.test.ts`**:
```typescript
describe('List Runs', () => {
  it('should list all runs in workspace', async () => {
    // Setup test workspace with multiple runs
    const runs = await listRuns({ workDir: testWorkspace });
    expect(runs.length).toBeGreaterThan(0);
  });

  it('should filter resumable runs', async () => {
    const runs = await listRuns({ workDir: testWorkspace, resumable: true });
    runs.forEach(run => {
      expect(['INTERRUPTED', 'WAITING_FOR_INPUT', 'FAILED', 'COMPLETED'])
        .toContain(run.status);
    });
  });

  it('should return only first run with --first', async () => {
    const runs = await listRuns({ workDir: testWorkspace, first: true });
    expect(runs.length).toBe(1);
  });
});
```

**Success Criteria**:
- [ ] All unit tests pass
- [ ] Coverage ≥ 90% for new code

#### 2.5.2 Integration Tests

**Update existing tests to remove LATEST dependency**:
```bash
# Files to update (15 files using LATEST)
tests/e2e/session-cleanup.test.ts
tests/e2e/continue-command.test.ts
tests/e2e/human-in-loop.test.ts
tests/e2e/hook-workflow.test.ts
tests/e2e/error-handling-journey.test.ts
tests/e2e/new-user-onboarding.test.ts
tests/e2e/resume-workflow.test.ts
tests/e2e/multi-workspace-journey.test.ts
tests/integration/multi-run-history.test.ts
tests/integration/interactive-resume.test.ts
tests/integration/version-migration.test.ts
tests/integration/journal-resumability.test.ts
tests/integration/workspace-isolation.test.ts
tests/unit/context.test.ts
```

**Example migration pattern**:
```diff
- const latestFile = path.join(deltaDir, 'LATEST');
- const runId = await fs.readFile(latestFile, 'utf-8');
+ // Get run ID from delta run output
+ const output = JSON.parse(stdout);
+ const runId = output.run_id;
```

**Create `tests/integration/client-run-id.test.ts`**:
```typescript
describe('Client-Generated Run ID', () => {
  it('should accept custom run ID', async () => {
    const customId = 'custom-run-001';
    await runDelta(['run', '--run-id', customId, '-m', 'Test']);

    // Verify run directory exists
    const runPath = path.join(workDir, '.delta', customId);
    const exists = await fs.stat(runPath);
    expect(exists.isDirectory()).toBe(true);
  });

  it('should reject duplicate run ID', async () => {
    const customId = 'duplicate-id';
    await runDelta(['run', '--run-id', customId, '-m', 'Test 1']);

    // Attempt duplicate
    await expect(
      runDelta(['run', '--run-id', customId, '-m', 'Test 2'])
    ).rejects.toThrow('already exists');
  });
});
```

**Create `tests/integration/orphan-recovery.test.ts`**:
```typescript
describe('Orphan Run Recovery', () => {
  it('should clean up and resume orphaned run', async () => {
    // Start run
    const proc = spawn('delta', ['run', '--run-id', 'orphan-test', '-m', 'Task']);
    await waitForRunning('orphan-test');

    // Kill with SIGKILL
    proc.kill('SIGKILL');
    await delay(100);

    // Attempt continue
    const result = await runDelta(['continue', '--run-id', 'orphan-test']);
    expect(result.status).toBe('INTERRUPTED');  // Auto-cleaned
  });
});
```

**Success Criteria**:
- [ ] All integration tests pass
- [ ] Client-generated ID tests pass
- [ ] Orphan recovery tests pass

#### 2.5.3 E2E Tests

**Create `tests/e2e/concurrent-runs.test.ts`**:
```typescript
describe('Concurrent Runs (E2E)', () => {
  it('should support 2 agents running concurrently in same workspace', async () => {
    const workDir = createTestWorkspace();

    // Start two runs concurrently
    const run1 = spawn('delta', ['run', '--run-id', 'concurrent-1', '-w', workDir, '-m', 'Task 1']);
    const run2 = spawn('delta', ['run', '--run-id', 'concurrent-2', '-w', workDir, '-m', 'Task 2']);

    // Wait for both to complete
    await Promise.all([waitForExit(run1), waitForExit(run2)]);

    // Verify both runs exist and have separate histories
    const deltaDir = path.join(workDir, '.delta');
    const run1Dir = path.join(deltaDir, 'concurrent-1');
    const run2Dir = path.join(deltaDir, 'concurrent-2');

    expect(await fs.stat(run1Dir)).toBeTruthy();
    expect(await fs.stat(run2Dir)).toBeTruthy();
  });
});
```

**Create `tests/e2e/output-formats.test.ts`**:
```typescript
describe('Output Formats (E2E)', () => {
  it('should output structured summary in text mode', async () => {
    const { stdout } = await runDelta(['run', '-m', 'Test', '--format', 'text']);
    expect(stdout).toContain('--- Run Summary ---');
    expect(stdout).toContain('Status:');
  });

  it('should output valid JSON in json mode', async () => {
    const { stdout } = await runDelta(['run', '-m', 'Test', '--format', 'json']);
    const result = JSON.parse(stdout);
    expect(result.schema_version).toBe('2.0');
  });

  it('should output pure data in raw mode', async () => {
    const { stdout } = await runDelta(['run', '-m', 'Test', '--format', 'raw']);
    expect(stdout).not.toContain('Run Summary');
  });
});
```

**Success Criteria**:
- [ ] All E2E tests pass
- [ ] Concurrent runs work without conflicts
- [ ] Output formats work in real scenarios

---

### Phase 6: Documentation & Examples (Days 12-13)

**Goal**: Update all documentation and examples to v1.10.

**Duration**: 2 days

**Dependencies**: Phases 1-5 complete

**Tasks**:

#### 2.6.1 Update Core Documentation

**Update `CLAUDE.md`**:
- Remove all references to LATEST
- Update CLI command examples (add --run-id)
- Update directory structure diagram
- Update "Essential Commands" section
- Add delta list-runs examples

**Update `docs/api/cli.md`**:
- Document --run-id parameter
- Document --format parameter
- Document --force parameter
- Document delta list-runs command
- Update all examples

**Update `docs/guides/getting-started.md`**:
- Update CLI examples
- Show delta list-runs usage
- Explain client-generated run IDs

**Success Criteria**:
- [ ] CLAUDE.md is accurate and concise
- [ ] API docs are complete
- [ ] Guides reflect v1.10 behavior

#### 2.6.2 Update Examples

**Update all 8 examples**:
- `examples/1-basics/hello-world/` - Simple v1.10 patterns
- `examples/2-core-features/interactive-shell/` - Show delta list-runs
- `examples/2-core-features/python-repl/` - No changes needed
- `examples/2-core-features/memory-folding/` - No changes needed
- `examples/3-advanced/delta-agent-generator/` - Update generated code
- `examples/3-advanced/code-reviewer/` - Show automation patterns
- `examples/3-advanced/research-agent/` - Show concurrent patterns
- Add new example: `examples/3-advanced/concurrent-planner/` - Demonstrate Plan-Execute pattern

**Success Criteria**:
- [ ] All examples run successfully
- [ ] README files updated
- [ ] Examples demonstrate v1.10 features

---

## 3. Risk Assessment & Mitigation

### 3.1 High-Risk Areas

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Breaking changes break all tests** | High | High | Update tests incrementally in Phase 2 |
| **Janitor fails to detect PID reuse** | Medium | Low | Comprehensive unit tests + process name check |
| **Cross-host detection false positives** | Medium | Medium | Provide --force escape hatch |
| **Output formatting breaks automation** | High | Medium | Extensive integration tests with real scripts |
| **Missing LATEST breaks third-party tools** | Medium | Low | Document breaking change prominently |

### 3.2 Mitigation Strategies

**Incremental Testing**:
- Run full test suite after each phase
- Keep master branch always green
- Use feature branches for risky changes

**Rollback Plan**:
- Git tags at each phase completion
- Documented rollback procedures (see Section 7)
- Preserve compatibility shims if needed

**Communication**:
- Clear breaking change warnings in commit messages
- Update CHANGELOG.md incrementally
- Provide migration examples in documentation

---

## 4. Success Criteria

### 4.1 Functional Requirements

- [ ] LATEST file completely removed from codebase
- [ ] Client-generated run ID works correctly
- [ ] Janitor mechanism safely cleans orphaned runs
- [ ] Three output formats (text/json/raw) work correctly
- [ ] delta list-runs command works
- [ ] --force flag bypasses cross-host checks
- [ ] Exit codes are standardized

### 4.2 Quality Requirements

- [ ] All existing tests pass (after migration)
- [ ] New unit tests: ≥90% coverage
- [ ] New integration tests: all key scenarios covered
- [ ] E2E tests: 100% P0+P1 journeys pass
- [ ] No regressions in existing functionality

### 4.3 Documentation Requirements

- [ ] CLAUDE.md updated
- [ ] API documentation complete
- [ ] All 8 examples updated
- [ ] Migration guide complete
- [ ] CHANGELOG.md updated

---

## 5. Rollback Plan

### 5.1 Rollback Triggers

Rollback if:
- More than 30% of tests fail after Phase 3
- Critical bug discovered in Janitor mechanism
- Production workloads fail unexpectedly
- Timeline exceeds 15 days with <50% completion

### 5.2 Rollback Procedure

**Step 1: Identify Rollback Point**
```bash
git log --oneline | grep "Phase [0-9] Complete"
# Select the last stable phase tag
```

**Step 2: Create Rollback Branch**
```bash
git checkout -b rollback-v1.10-$(date +%Y%m%d)
git reset --hard <phase-tag>
```

**Step 3: Restore Master**
```bash
git checkout main
git reset --hard <phase-tag>
git push --force-with-lease origin main
```

**Step 4: Communicate**
- Notify team of rollback
- Document rollback reason
- Create post-mortem issue

---

## 6. Timeline & Resource Estimation

### 6.1 Detailed Timeline

| Phase | Duration | Start | End | Deliverable |
|-------|----------|-------|-----|-------------|
| **Phase 1** | 1.5-2 days | Day 1 | Day 2 | Type definitions complete |
| **Phase 2** | 2-3 days | Day 2 | Day 4 | Janitor + LATEST removal |
| **Phase 3** | 2 days | Day 5 | Day 6 | CLI enhancements |
| **Phase 4** | 1.5-2 days | Day 7 | Day 8 | Output formatting |
| **Phase 5** | 3-4 days | Day 9 | Day 11 | Testing complete |
| **Phase 6** | 2 days | Day 12 | Day 13 | Documentation done |

**Total**: 10-13 days

### 6.2 Resource Requirements

**Engineering**:
- 1 senior engineer (full-time)
- Code reviews (2-3 hours per phase)

**Testing**:
- Automated tests (continuous)
- Manual QA (2-3 hours for E2E validation)

**Documentation**:
- Technical writer (optional, 2 days for polish)

### 6.3 Milestone Markers

- **Day 2**: Types & Schemas complete → PR #1
- **Day 4**: Core infrastructure ready → PR #2
- **Day 6**: CLI functional → PR #3
- **Day 8**: Output formatting done → PR #4
- **Day 11**: All tests green → PR #5
- **Day 13**: v1.10.0 release candidate ready

---

## 7. Implementation Notes

### 7.1 Commit Strategy

**Atomic Commits**:
- Each phase should be 1-3 commits
- Commit messages reference design doc (v1.10-frontierless-workspace.md)
- Tag commits at phase boundaries

**Example Commit Messages**:
```
feat(v1.10): Phase 1 - Add RunResult v2.0 Schema and output format types

- Add RunResult v2.0 Schema with conditional fields
- Add OutputFormat enum (text/json/raw)
- Extend RunMetadata with PID tracking fields
- Update CLI option types for --run-id, --format

Ref: docs/architecture/v1.10-frontierless-workspace.md
```

### 7.2 Code Review Checklist

For each PR:
- [ ] All tests pass
- [ ] TypeScript compiles without errors
- [ ] No console.log() left in code
- [ ] Error messages are user-friendly
- [ ] Documentation updated
- [ ] CHANGELOG.md entry added

### 7.3 Testing During Development

**Run tests continuously**:
```bash
# Watch mode for unit tests
npm run test:unit -- --watch

# Quick validation
npm run test:quick

# Full suite before PR
npm run test:all
```

---

## 8. Conclusion

This implementation plan provides a structured, low-risk path to delivering Delta Engine v1.10. By following the phase-by-phase approach with continuous testing and validation, we ensure that the system remains stable and deployable throughout the implementation.

**Key Principles**:
1. **Incremental delivery** - Each phase delivers value
2. **Safety first** - Comprehensive testing at every step
3. **Clear communication** - Documentation updated alongside code
4. **Rollback readiness** - Always have a safe fallback

**Next Steps**:
1. Review and approve this implementation plan
2. Create tracking issues for each phase
3. Begin Phase 1 implementation
4. Schedule daily standup for progress tracking

---

**Approval Signatures**:
- [ ] Technical Lead: _______________
- [ ] Project Manager: _______________
- [ ] QA Lead: _______________

**Document Version**: 1.0
**Last Updated**: October 14, 2025
