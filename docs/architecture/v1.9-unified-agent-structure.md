# Delta Engine Architecture Specification v1.9: Unified Agent Structure and Compositional Configuration

**Version**: 1.9.0
**Date**: October 13, 2025
**Status**: Final Specification
**Author**: Delta Engine Chief Architect

---

## 1. Overview and Motivation

Delta Engine's core mission is to provide "engineering effective and simple" tools to accelerate AI Agent prototyping. Through the evolution from v1.1 to v1.8, the legacy `config.yaml` file from the v1.0 era has proven inadequate for its increasingly diverse responsibilities. The ambiguous naming and monolithic structure have become apparent limitations. Additionally, as Agent complexity has grown, the need for configuration modularity and reusability has become urgent.

Version 1.9 aims to achieve clarity, standardization, and modularity in the Agent configuration system through a comprehensive refactoring. Core achievements of this refactoring include:

1. **Clear Naming Convention**: Introducing `agent.yaml` to replace `config.yaml`, achieving ultimate intuitiveness.
2. **Compositional Configuration**: Introducing the `imports` mechanism to implement a "single-file first + explicit composition" flexible architecture.
3. **Separation of Concerns**: Decoupling lifecycle hooks into an independent `hooks.yaml` file.

## 2. Core Philosophy and Design Principles

This refactoring strictly adheres to Delta Engine's core philosophy:

### 2.1 Engineering Effective and Simple

Architecture design must serve engineering practice. We choose a "single-file first" pattern, ensuring that for 80% of simple scenarios, developers can quickly start and iterate, avoiding the cognitive overhead of over-modularization.

### 2.2 Explicit over Implicit

For composing core capabilities, we adopt explicit `imports` declarations rather than implicit "auto-discovery." This ensures the completeness and transparency of `agent.yaml` as the configuration entry point, aligning with our commitment to expert users.

### 2.3 Composition Defines Intelligence

Through the `imports` mechanism, we extend the "composition" philosophy to the configuration file level, allowing developers to package, share, and reuse common capability sets, laying the foundation for a future ecosystem.

### 2.4 Progressive Disclosure

For advanced features (such as `context.yaml` and `hooks.yaml`), we adopt a "convention over configuration" pattern. They are optional and only appear when users need them, lowering the barrier for beginners.

## 3. Detailed Specification: Agent Project Structure

v1.9 defines a new, standardized Agent project structure.

### 3.1 Standard Project Structure

```
/path/to/MyAgent/
├── agent.yaml          # [Required] Core definition: metadata, LLM config, tools, imports
├── system_prompt.md    # [Required] Core instructions

# --- Optional advanced configuration (convention over configuration) ---
├── context.yaml        # [Optional] Cognitive strategy (v1.6+)
├── hooks.yaml          # [Optional] Lifecycle hooks (v1.9+)

# --- Resources and modules ---
├── tools/              # (Optional) Private tool scripts directory
└── modules/            # (Optional) Importable configuration modules directory
    └── file_ops.yaml
```

### 3.2 Core File Definitions and Responsibilities

We establish clear responsibility boundaries and loading strategies:

| File | Responsibility | Contents | Loading Strategy | Status |
|------|---------------|----------|------------------|---------|
| **`agent.yaml`** | Agent main definition and capability entry point | `metadata`, `llm_config`, `tools`, `imports` | **Explicit loading** (configuration entry point) | **Required** |
| `context.yaml` | Cognitive and perception strategy | `sources` list (v1.6) | **Convention loading** (overrides default if exists) | Optional |
| `hooks.yaml` | Lifecycle reaction patterns | `lifecycle_hooks` definition | **Convention loading** (auto-applied if exists) | Optional |

### 3.2.1 `agent.yaml`: Core and Entry Point

`agent.yaml` replaces `config.yaml` as the Agent's core definition file and sole configuration entry point. It embodies the "single-file + explicit composition" architecture strategy.

### 3.2.2 `hooks.yaml`: Separation of Concerns

Moving `lifecycle_hooks` from the core definition into an independent `hooks.yaml` file. The engine automatically detects and loads this file at startup if it exists.

## 4. Schema Specification

### 4.1 `agent.yaml` Schema (v1.9)

```yaml
# === 1. Metadata ===
name: MyAgent
description: A brief description of the agent.

# === 2. Core Configuration / Thinking ===
llm_config:
  model_name: "gpt-4o"
  temperature: 0.2
  # ... other LLM parameters

# === 3. Capability Composition (v1.9 new) ===
# Optional: Import tool definitions from external YAML files.
imports:
  - ./modules/file_ops.yaml
  - ./modules/web_search.yaml
  # Future extension support for remote imports, e.g.:
  # - npm:@delta/common-tools/v1.0.0/base.yaml

# === 4. Capability Definition / Tools ===
# Optional: Directly define agent tools here.
# Follows v1.7 exec:/shell: syntax sugar specification.
tools:
  - name: list_files
    description: "List files in the current directory."
    exec: "ls -F ${directory}"

  - name: summarize_report
    description: "Summarize the final report."
    exec: "python3 ${AGENT_HOME}/tools/summarize.py ${file_path}"
```

### 4.2 `hooks.yaml` Schema (v1.9)

```yaml
# Define Agent's reaction patterns to engine lifecycle events.
# Root node of this file is the lifecycle_hooks object.

# Execute before LLM call
pre_llm_req:
  command: ["python3", "${AGENT_HOME}/tools/context_optimizer.py"]

# Execute before tool execution
pre_tool_exec:
  command: ["${AGENT_HOME}/tools/validate_args.sh"]

# Execute at run end (regardless of success or failure)
on_run_end:
  command: ["delta-sessions", "cleanup"]
```

## 5. Composition Mechanism: `imports` Detailed Explanation

The `imports` mechanism is core to achieving modularity and reusability in v1.9.

### 5.1 Syntax and Behavior

- `imports` field is a string array.
- **Path Resolution**: Paths are relative to the directory where the current `agent.yaml` file is located (i.e., `${AGENT_HOME}`).
- **Content Requirements**: Imported YAML files must be objects containing a `tools` list.

**Example: Imported file (`modules/file_ops.yaml`)**

```yaml
# Shareable file operation toolset
tools:
  - name: read_file
    exec: "cat ${path}"
  - name: write_file
    exec: "tee ${path}"
    stdin: content
```

### 5.2 Merging Logic

The engine executes the following merging logic when loading configurations:

1. **Parse `imports`**: Read and parse all imported files in order (supports recursive imports, but requires circular dependency detection).
2. **Merge**: Merge all imported `tools` lists with the `tools` list locally defined in `agent.yaml`.
   - **Merge Order**: tools from `imports[0]` + tools from `imports[1]` + ... + locally defined tools.
3. **Conflict Resolution (Last Write Wins)**: If tools with the same name appear, later-loaded definitions override earlier ones. This means **locally defined tools have the highest priority**, allowing users to override default implementations in imported modules.

### 5.3 Security Boundaries

To ensure system security, the `imports` mechanism must follow strict path restrictions:

- **Prohibit Path Traversal**: Import paths must not contain `../` or other attempts to access parent directories.
- **Root Directory Restriction**: Resolved absolute paths must strictly reside within the Agent project directory (`${AGENT_HOME}`). The engine must validate this to prevent arbitrary file reading.

## 6. Implementation Architecture

### 6.1 Configuration Loader Workflow

The engine's configuration loading module needs upgrading to support the new file structure and mechanism.

**Loading Process:**

1. **Locate Main Config**: Engine first looks for `${AGENT_HOME}/agent.yaml`. Performs compatibility check (looks for `config.yaml`, see Section 7).
2. **Parse and Import (`imports`)**:
   - Parse main configuration file contents.
   - If `imports` field exists, perform path security validation (Section 5.3), recursively load files, and execute tool merging logic (Section 5.2).
3. **Load `hooks.yaml` (convention loading)**:
   - Check if `${AGENT_HOME}/hooks.yaml` exists and load it.
   - **Note**: Handle compatibility logic with legacy `lifecycle_hooks` field (see Section 7 for details).
4. **Load `context.yaml` (convention loading)**:
   - Check if `${AGENT_HOME}/context.yaml` exists. If it exists, use it to configure Context Builder; otherwise, use default strategy.

## 7. Migration Path and Compatibility

We adopt a "compatible and inclusive, gradual deprecation" strategy to provide a smooth migration path.

### 7.1 Phase One: Compatibility Period (v1.9)

In v1.9, implement the following compatibility strategies:

1. **Filename Compatibility**:
   - Engine prioritizes `agent.yaml`. If not found, falls back to `config.yaml`.
   - If `config.yaml` is loaded, print clear `[DEPRECATION WARNING]`, prompting users to rename.
   - If both exist, `agent.yaml` takes priority and a warning is printed.

2. **`hooks` Compatibility**:
   - Engine prioritizes loading hooks from `hooks.yaml`.
   - If `hooks.yaml` doesn't exist but the main config file contains `lifecycle_hooks` field, load from it and print `[DEPRECATION WARNING]` prompting user to migrate to `hooks.yaml`.

3. **Tool Updates**:
   - `delta init` command updated to generate `agent.yaml` structure by default.
   - All documentation and examples comprehensively updated to v1.9 specification.

### 7.2 Phase Two: Remove Compatibility (v2.0)

With the next major version (v2.0) release:

1. Formally remove support for `config.yaml`.
2. Formally remove support for loading `lifecycle_hooks` from `agent.yaml` (only support `hooks.yaml`).

## 8. Conclusion

The v1.9 architecture refactoring is another profound practice of our core philosophy of "engineering effective and simple." By introducing `agent.yaml`, achieving separation of concerns (`hooks.yaml`), and providing powerful composition capabilities through the `imports` mechanism, we achieve a unified architecture that is **extremely simple in intuitiveness, highly flexible in engineering, and logically self-consistent in philosophy**.

This new architectural paradigm will greatly improve developer efficiency, reduce cognitive load, and lay a solid foundation for the future ecosystem evolution of Delta Engine.
