# v1.4 PTY-based Sessions: Deprecation Notice

**Date**: October 2, 2025
**Status**: Deprecated / Experimental
**Replacement**: v1.5 Simplified Sessions (command-based)

---

## Status

The PTY-based session management system implemented in v1.4 has been **moved to experimental status** and is no longer the recommended approach for production use.

**Current Status:**
- ✅ Code preserved in `src/sessions-pty/`
- ✅ CLI available as `delta-sessions-pty` (experimental)
- ❌ Not documented in main README or CLAUDE.md
- ❌ Not recommended for new agents
- ⚠️ May be removed in v2.0

---

## Why Was PTY Approach Abandoned?

### 1. Fundamental Mismatch with LLM Interaction Model

**Problem**: LLMs operate in request-response cycles, cannot monitor real-time output.

**Evidence from `claude-code-workflow` example:**
```yaml
# LLM needs to guess timing
- name: sleep
  description: |
    Wait for a specified number of seconds.
    IMPORTANT: Claude Code is very slow (minutes, not seconds).
    Typical wait times:
    - After submitting task: 10-30 seconds
    - Between checks: 20-40 seconds
    - For complex tasks: up to 60 seconds
```

**Pattern Required:**
```
LLM: write("command\n")
LLM: sleep(10)
LLM: read(timeout=5000)
LLM: analyze output
LLM: if incomplete, sleep(20) and read again
LLM: if still incomplete, sleep(40) and read again
...
```

This polling pattern is:
- ❌ Inefficient (multiple round-trips)
- ❌ Unreliable (timing guesses)
- ❌ High latency (cumulative waits)
- ❌ High cost (multiple LLM calls just to wait)

### 2. Escape Sequence Complexity

**Problem**: ANSI escape sequences are not LLM-friendly.

**Even with semantic keys:**
```yaml
- name: claude_send_key
  description: |
    Send control keys like:
    - arrow_up, arrow_down, arrow_left, arrow_right
    - enter, tab, escape, space, backspace
```

**LLM still needs to understand:**
- Multi-line input mode (single-enter triggers it)
- Double-enter submission pattern
- Triple-enter in some cases
- When to use arrow keys vs text input
- ANSI color codes in output parsing

**Example complexity from config:**
```yaml
INPUT SUBMISSION PATTERN:
1. First attempt: Send task text with \n
2. Read output and analyze:
   - Animation visible → Success!
   - Cursor on next line but no animation → Multi-line mode
3. If multi-line mode:
   Send "\n" (another Enter)
4. Read output again
5. If still not processing:
   Send "\n" one more time (triple-enter)
```

### 3. Limited Practical Use Cases

**PTY truly needed for:**
- Interactive text editors (vim, nano, emacs)
- Terminal UI apps (top, htop, nethack)
- Interactive menus (dialog, whiptail)
- ncurses applications

**Reality:**
- ❌ These are better suited for human interaction
- ❌ LLMs struggle with terminal state and cursor position
- ❌ Visual feedback (colors, animations) wasted on LLMs

**What LLMs actually need:**
- ✅ Bash command execution (non-interactive)
- ✅ Python script execution (batch)
- ✅ Database query execution (SQL commands)
- ✅ File operations (ls, cat, grep)

**Insight**: 90% of agent use cases don't need PTY at all.

### 4. Implementation Complexity

**Code Statistics:**
```
src/sessions-pty/
├── holder.ts            191 lines  (Detached process management)
├── socket-utils.ts      132 lines  (Unix socket IPC)
├── session.ts           310 lines  (PTY wrapper + reconnect)
├── manager.ts           252 lines  (High-level API)
├── escape-parser.ts      80 lines  (Escape sequence parsing)
├── key-codes.ts         120 lines  (50+ key mappings)
├── storage.ts           180 lines  (Metadata persistence)
├── types.ts             136 lines  (Type definitions)
└── index.ts              20 lines
                        ─────────
Total:                  1421 lines

src/sessions-pty-cli.ts  427 lines  (CLI interface)
                        ─────────
Grand Total:            1848 lines
```

**Complexity Sources:**
- Holder process lifecycle (spawn, crash detection, cleanup)
- Unix socket IPC protocol (JSON RPC)
- PTY management (node-pty wrapper, buffer handling)
- Cross-process state synchronization
- Escape sequence parsing (14 patterns)
- Key code mapping (50+ keys)

**Development Cost:**
- v1.4.0: 2 days (GNU Screen approach, failed)
- v1.4.2: 9 POC scripts + 3 days (Unix Socket approach, succeeded technically)
- Total: ~5 days for 1848 lines that don't match LLM usage patterns

### 5. Debugging Difficulty

**Challenges:**
- Cross-process debugging (CLI ↔ holder via socket)
- PTY output buffering and timing issues
- Stale socket detection and cleanup
- Zombie process prevention
- Unix socket path length limits (104 bytes on macOS)

**Example from investigation:**
```bash
# Debugging requires:
cat ~/.sessions/sess_abc123/metadata.json
cat /tmp/delta-sock-sess_abc123.sock  # Socket location
lsof -p <holder_pid>  # Check file descriptors
ps aux | grep holder  # Check process status
```

---

## Technical Achievements (Worth Preserving)

Despite being unsuitable for LLMs, the PTY implementation has technical merit:

### Successfully Solved Problems

1. **Cross-Process Session Access**
   - Unix socket IPC enables multiple CLI processes to access same session
   - Validated with 30 concurrent clients (no corruption)
   - Latency: <5ms per operation

2. **Holder Crash Detection**
   - Automatic stale socket cleanup
   - Graceful reconnection on holder restart
   - Zombie process prevention

3. **Full PTY Emulation**
   - node-pty integration for true terminal behavior
   - ANSI escape sequence support
   - Job control (Ctrl+C, Ctrl+Z)

4. **POC-First Validation Methodology**
   - 9 standalone POC scripts validated architecture assumptions
   - Avoided wrong implementation (GNU Screen approach)
   - See `.story/decisions/005-poc-first-validation.md`

### Code Quality

- ✅ TypeScript + Zod validation throughout
- ✅ Comprehensive error handling
- ✅ Unit + integration + E2E tests
- ✅ Cross-platform (macOS, Linux)

---

## When to Use PTY Sessions (Experimental)

If you **must** use PTY, `delta-sessions-pty` is available:

### Valid Use Cases

1. **Educational/Research**
   - Studying LLM-terminal interaction patterns
   - Experimenting with real-time PTY control

2. **Human-Supervised Workflows**
   - Human monitors terminal output
   - LLM assists with command suggestions
   - Example: Pair programming with Claude

3. **Specific Interactive Apps**
   - Controlling actual vim/emacs sessions
   - Automating ncurses applications
   - **Note**: High cognitive load, not recommended

### How to Use

```bash
# Install (experimental)
npm install delta-engine

# CLI available
delta-sessions-pty start bash -i
delta-sessions-pty write sess_abc "ls -la\n"
delta-sessions-pty read sess_abc --timeout 2000
delta-sessions-pty end sess_abc
```

**Config Example:**
```yaml
tools:
  - name: shell_start
    command: [delta-sessions-pty, start, bash, "-i"]
  - name: shell_write
    command: [delta-sessions-pty, write]
    # ... (see v1.4 design doc for full config)
```

**Documentation:**
- Design: `docs/architecture/v1.4-sessions-design.md`
- API Reference: Section 4 of design doc
- Examples: `examples/claude-code-workflow/` (experimental)

---

## Migration to v1.5 Simplified Sessions

**For new agents**: Use v1.5 simplified sessions (command-based).

**For existing PTY agents**: See `docs/migration/v1.4-to-v1.5.md`.

**Key Differences:**

| Aspect | PTY (v1.4) | Simplified (v1.5) |
|--------|------------|-------------------|
| API | `start`, `write`, `read`, `end` | `start`, `exec`, `end` |
| Interaction | Async (write → sleep → read) | Sync (exec → complete output) |
| Output | Streaming, buffered | Batch, complete |
| Timing | LLM must guess | No guessing needed |
| Complexity | 1848 lines | ~600 lines |
| Use Cases | PTY apps (vim, top) | Commands (bash, Python) |

**Example Conversion:**

Before (PTY):
```yaml
- name: shell_write
  command: [delta-sessions, write]
  parameters:
    - name: session_id
      inject_as: argument
    - name: input
      inject_as: stdin
```

After (Simplified):
```yaml
- name: session_exec
  command: [delta-sessions, exec]
  parameters:
    - name: session_id
      inject_as: argument
    - name: command
      inject_as: stdin
```

---

## Lessons Learned

### For Future Development

1. **Validate Usage Patterns, Not Just Technical Feasibility**
   - PTY approach was technically sound (all POCs passed)
   - But didn't match LLM interaction model (request-response)
   - Lesson: Test with actual LLM workflows before full implementation

2. **Simplicity > Feature Completeness**
   - PTY provides 100% terminal compatibility
   - But 90% of features unused for agent automation
   - Lesson: Design for actual use cases, not theoretical completeness

3. **LLMs Are Not Humans**
   - Human-friendly features (colors, animations, menus) don't help LLMs
   - LLMs need structured, complete output (JSON)
   - Lesson: Design APIs for LLM strengths, not human UX patterns

4. **Code as Research Investment**
   - 1848 lines "wasted" → Actually valuable research artifact
   - Proved what **doesn't** work is as valuable as what works
   - Lesson: Failed experiments are learning, not waste

### Updated Decision Records

See `.story/INDEX.md`:
- Decision #6: "Abandon PTY-based sessions (v1.4 pivot)"
- Trap: "LLM Real-time Interaction Mismatch"

---

## Future of PTY in Delta Engine

### v1.5 - v1.9
- PTY code preserved in `src/sessions-pty/`
- CLI available as `delta-sessions-pty` (experimental)
- No active development or new features

### v2.0+
- Evaluate usage metrics
- If <1% of agents use PTY → Remove code entirely
- If research interest exists → Keep as reference implementation

---

## Conclusion

The PTY-based session management was a **necessary experiment** that revealed fundamental mismatches between terminal emulation and LLM capabilities.

**Technical Success**: Fully functional PTY management system.
**Product Failure**: Doesn't fit LLM interaction patterns.

**Result**: Deprecated in favor of v1.5 simplified command-based sessions.

**Value Preserved**:
- Code reference for future PTY needs
- Lessons learned about LLM-terminal interaction
- POC-first validation methodology

---

**Recommended Action**: Use `delta-sessions` (v1.5) for all new agents.

**Questions**: See `docs/architecture/v1.5-sessions-simplified.md` for new approach.
