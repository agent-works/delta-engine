This document is the latest architectural design specification v1.1 for Delta Engine. It integrates the MVP foundational design from v1.0, the core philosophy from the Delta Engine Manifesto, and importantly incorporates the in-depth discussion outcomes regarding the Current Working Directory (CWD) architecture.

The core update in v1.1 is the establishment of CWD as the physical embodiment of the "Environment is the Interface" philosophy, with a thorough redesign of its internal structure, interaction protocols, and execution mechanisms. This document aims to provide comprehensive guidance for subsequent development.

---

# Delta Engine Architecture Specification v1.1

## 1. Project Vision and Strategy

### 1.1 Value North Star (The WHY)

The core mission of the Delta Engine project is to create an efficient and flexible experimental platform for our internal meta-prompt and AI Agent prototype research team, aimed at **fundamentally accelerating the R&D, testing, and iteration cycles of AI Agent prototypes**.

Delta Engine is positioned as a "scientific instrument," whose primary value lies in accelerating the process of scientific discovery itself.

### 1.2 Target Users and Scenarios (The WHO)

- **User Profile:** Expert-level researchers with advanced AI knowledge, proficient in prompt engineering and Agent architecture.
- **Core Needs:** Pursuit of ultimate flexibility, transparency, and control to solve the bottleneck of **slow prototype iteration speed**. They desire the platform to be an empowering tool rather than a constraining framework.

### 1.3 Strategic Positioning

Delta Engine occupies a unique niche through its radical adherence to minimalism and Unix philosophy. Its core competitiveness stems from the purity and consistency of its architectural philosophy, forming a sharp contrast with increasingly complex "all-in-one" frameworks in the mainstream market.

## 2. Core Philosophy and Design Principles

Delta Engine's architecture is rooted in a tightly interconnected, self-consistent set of design philosophies.

### 2.1 Everything is a Command

The engine itself does not include any built-in specific tools. All functionalities, from file operations to invoking other Agents, are implemented by executing external command-line programs. This provides unparalleled extensibility, simplifying the engine's core responsibility to being a command scheduler and executor.

### 2.2 The Environment is the Interface

The interface through which Agents interact with the environment and tools is highly simplified to a single core concept—**the Current Working Directory (CWD)**. CWD is not merely a storage location; it is the physical embodiment of the architectural philosophy, serving as the "State Bus" for communication between Agents and the sole "API Contract."

### 2.3 Composition Defines Intelligence

System intelligence should not stem from an increasingly bloated central engine, but rather emerge from combining multiple functionally specialized "atomic Agents." "Composition over inheritance" is the highest principle guiding all feature development.

## 3. System Architecture Overview

Delta Engine adopts a **Stateless Core** design. The engine process itself does not preserve state across cycles; the CWD is the Single Source of Truth.

The system consists of three main components:

1. **delta CLI:** The stateless execution core.
2. **Agent Project:** A self-contained directory defining the Agent's capabilities (Prompt, Tools, Config).
3. **Working Directory (CWD):** The physical environment containing the Agent's work artifacts and the engine's control data.

## 4. Agent Definition and Configuration

### 4.1 Agent Project Structure (Independent and Self-Contained)

Each Agent is a project directory that can be independently distributed and version-controlled.

```yaml
/path/to/MySearchAgent/
├── config.yaml           # Core configuration file: metadata, LLM parameters, tool manifest, hook definitions
├── system_prompt.txt     # Agent's system prompt
└── tools/                # (Optional) Storage for custom tool scripts or hook scripts specific to this Agent
    └── web_search.sh
```

### 4.2 delta Command-Line Interface (CLI)

The engine is interacted with through the `delta` CLI. The core command is `run`.

```yaml
delta run --agent <agent_path> \
	--task "<task_description>" \
	--work-dir <path_to_work_dir>
```

- `--work-dir`: (Core parameter) Specifies the working directory (CWD) for this run. If not provided, the engine will automatically create a default workspace.

### 4.3 config.yaml Core Specification

The `config.yaml` file defines the Agent's behavior, capabilities, and extension hooks.

```yaml
# Agent metadata
name: OrchestratorAgent
description: An orchestrator agent.

# LLM configuration
llm_config:
  model_name: "gpt-4o"
  temperature: 0.2

# Lifecycle Hooks (v1.1 new addition)
# Allows external commands to intervene in the engine's core workflow
lifecycle_hooks:
  # Example: Execute context optimization script before calling LLM
  # ${AGENT_HOME} will be replaced at runtime with the absolute path to this Agent project.
  pre_llm_req:
    command: ["python3", "${AGENT_HOME}/tools/context_optimizer.py"]

# Tool Manifest
# Embodies the "Everything is a Command" philosophy.
tools:
  # Example 1: Basic file operations (calling system commands)
  - name: list_files
    description: "List files in the specified directory. Paths should be relative to the current working directory."
    command: ["ls", "-F"]
    parameters:
      - name: directory
        type: string
        default: "."
        inject_as: argument # Inject this parameter as an argument at the end of the command line

  # Example 2: Passing content via standard input (stdin) (avoiding command injection risks)
  - name: write_file
    description: "Write specified content to a file."
    command: ["tee"] # Using 'tee' command can safely receive content from stdin and write to a file
    parameters:
      - name: filename
        type: string
        inject_as: argument
      - name: content
        type: string
        inject_as: stdin # Mark that this parameter's content is passed via stdin

  # Example 3: Calling Agent-specific custom tool scripts
  - name: search_web
    command: ["${AGENT_HOME}/tools/web_search.sh"]
    parameters:
      - name: query
        type: string
        inject_as: argument

  # Example 4: Agent orchestration tool (calling delta itself)
  - name: run_sub_agent
    description: "Execute a sub-Agent to complete a specific task."
    command: ["delta", "run"]
    parameters:
      - name: agent_path
        type: string
        inject_as: option # Inject as command-line option
        option_name: "--agent"
      - name: task
        type: string
        inject_as: option
        option_name: "--task"
      - name: work_dir
        type: string
        description: "Subdirectory path allocated for the sub-Agent, relative to the current working directory."
        inject_as: option
        option_name: "--work-dir"
```

## 5. CWD Architecture: State Bus (v1.1 Core)

The design of the CWD is the core of Delta Engine v1.1. It realizes the "Environment is the Interface" philosophy, defining how the engine records history, manages state, and provides extension interfaces.

### 5.1 Design Philosophy: Data Plane and Control Plane

The CWD is strictly divided into two domains to achieve decoupling of execution process and work artifacts:

1. **Data Plane (Workspace)** (CWD root directory):
    - The Agent's domain. Contains all task-related artifacts.
    - This space is mutable and persistent, representing the **current state** of the task.
2. **Control Plane** (`.delta/` directory):
    - The engine's domain. Hidden from the Agent.
    - Contains the complete history of how the workspace reached its current state and runtime interfaces.

```yaml
<CWD>/ (Workspace - Data Plane)
├── data.csv
├── report.md
└── .delta/ (Control Plane)
```

### 5.2 `.delta/` Top-Level Structure Specification

```yaml
<CWD>/.delta/
├── schema_version.txt    # [System] Protocol version identifier (e.g., "1.1")
├── runs/                 # [Core] Execution history repository
├── lock                  # [System] Concurrency control lock file (reserved for future use)
└── manifest.json         # [Optimization] Workspace self-description manifest (reserved for future use)
```

### 5.3 Execution History Repository (.delta/runs/)

`.delta/runs/` stores complete, independent snapshots of all Agent executions using this CWD. This implements "time machine" functionality and supports iterative workflows.

```yaml
.delta/runs/
├── <RUN_ID_1>/
├── <RUN_ID_2>/
└── LATEST  # Text file containing the most recent run ID
```

- `<RUN_ID>` format: `<YYYYMMDD_HHMMSS>_<ShortUUID>` (e.g., `20250926_120006_a1b2c3`).

Execution Mechanism (Iteration Support):

When `delta run` is launched in a specified CWD (whether for the first time or the Nth time), the engine first creates a new `<RUN_ID>` directory. The Agent process starts in the CWD root directory (Workspace), where it sees the file state accumulated from all previous runs and continues working on that basis.

### 5.4 Run Snapshot Structure (.delta/runs/<RUN_ID>/)

Each `<RUN_ID>` directory is an **immutable record** of a single execution, functionally divided into three core areas:

```yaml
.delta/runs/<RUN_ID>/
├── execution/          # High-level execution flow and state (The Spine)
│   ├── journal.jsonl   # [Required] Authoritative execution log (T-A-O loop).
│   ├── metadata.json   # [Required] Run summary and status.
│   └── engine.log      # (Optional) Raw stdout/stderr of the engine process.
│
├── configuration/      # Input configuration snapshot (Reproducibility Context)
│   ├── resolved_config.yaml
│   └── system_prompt.txt
│
└── runtime_io/         # Low-level I/O details and interface boundaries (The Interface Boundary)
    ├── hooks/            # Interaction details with lifecycle hooks
    ├── invocations/      # [New] Interaction details with LLM
    └── tool_executions/  # [New] Interaction details with tools/commands
```

### 5.4.1 Journal vs. Log Distinction

We explicitly distinguish between two types of records:

- **journal.jsonl (Execution Log):** The system's authoritative record and single source of truth. It is the Agent's "working memory." Used for context reconstruction and state recovery.
- **engine.log (Engine Log):** Internal implementation details and telemetry data of the engine process. Used for diagnosing engine failures.

## 6. Runtime Interface and I/O Details (v1.1 Core)

`.delta/runs/<RUN_ID>/runtime_io/` is the core interface boundary of the CWD. It stores detailed records of the engine's interactions with all external systems (LLM API, OS commands, lifecycle hook scripts). This allows `journal.jsonl` to remain concise while providing full-chain I/O audit capabilities.

### 6.1 Structure Overview

```bash
runtime_io/
├── invocations/      # Interactions with LLM
├── tool_executions/  # Interactions with tools/commands
└── hooks/            # Interactions with lifecycle hooks
```

We adopt a **Persistent Invocation Directory** design. Each external interaction has its own independent directory, providing ultimate debuggability.

### 6.2 LLM Invocation Details (runtime_io/invocations/)

This directory stores the exact input, output, and telemetry data for each LLM invocation. `THOUGHT` events in `journal.jsonl` are linked to records here via `llm_invocation_ref`.

```bash
runtime_io/invocations/
└── <INVOCATION_ID>/ (UUID)
    ├── request.json   # [Input] Final payload sent to LLM API (P_final).
    ├── response.json  # [Output] Raw response received from LLM API.
    └── metadata.json  # [Telemetry] Invocation details.
```

- **request.json:** Crucially important, it records the exact context the LLM actually "saw" after processing by the `pre_llm_req` hook.
- **metadata.json:** Contains `model_id`, `duration_ms`, `token_usage` (prompt/completion/total), `status`, etc.

### 6.3 Tool Execution Details (runtime_io/tool_executions/)

Observations in `journal.jsonl` are typically truncated or summarized. This directory preserves the complete raw output of tool executions. `ACTION_RESULT` events are linked to records here via `execution_ref`. We adopt a standardized execution record structure.

```bash
runtime_io/tool_executions/
└── <ACTION_ID>/ (UUID)
    ├── command.txt     # The actual command line executed.
    ├── stdout.log      # Complete standard output stream.
    ├── stderr.log      # Complete standard error stream.
    ├── exit_code.txt   # Exit code (e.g., "0").
    └── duration_ms.txt # Execution duration.
```

### 6.4 Lifecycle Hook Interface (runtime_io/hooks/)

Lifecycle hooks allow external commands to intervene in the engine's core workflow (e.g., for context engineering), which is the primary mechanism for engine extensibility.

### 6.4.1 Structure and API Contract

```bash
runtime_io/hooks/
  # Naming convention: <Step_Index>_<Hook_Name>
  └── <Step>_<HookName>/
        ├── input/              # Engine → Hook
        │   ├── context.json    # [Required] Metadata for hook trigger.
        │   └── payload.dat     # Main data payload.
        │
        ├── output/             # Hook → Engine
        │   ├── payload_override.dat # (Optional) Overridden main data payload.
        │   └── control.json    # (Optional) Structured control instructions.
        │
        └── execution_meta/     # Hook execution telemetry data (same structure as tool_executions)
            ├── command.txt
            ├── stdout.log
            ├── stderr.log
            ├── exit_code.txt
            └── duration_ms.txt
```

### 6.4.2 Hook Execution Protocol

When a lifecycle event is triggered, the engine executes the following standardized process:

1. **Prepare (Engine):** Create the invocation directory and write relevant data to `input/`.
2. **Execute (Engine & Hook):**
    - The engine executes the configured external command.
    - **CWD Convention:** The command's CWD is set to the **workspace root directory** (`<CWD>/`).
    - **Environment Injection (Communication Channel):** The engine injects the absolute path of the interaction directory via environment variables:

        ```bash
        export DELTA_RUN_ID=<RUN_ID>
        export DELTA_HOOK_IO_PATH=<Absolute_Path_to_Invocation_Dir/>
        ```

    - Hook scripts use the `DELTA_HOOK_IO_PATH` variable to locate their `input/` and `output/` directories for reading and writing.
3. **Capture (Engine):** Capture command execution details and write to `execution_meta/`.
4. **Ingest & Apply (Engine):** If the exit code is 0, the engine reads result files from `output/` and applies them to its internal workflow.

## 7. Core Data Structure: Execution Log (v1.1 Core)

`journal.jsonl` is the "spinal cord" in the Delta Engine architecture, carrying the execution flow, working memory, and system state. It uses JSON Lines format.

### 7.1 Event Envelope (Envelope Schema)

All events share a common envelope structure.

```json
{
  "seq": 1,
  // [Required] Sequence number. Strictly monotonically increasing integer (starting from 1), ensuring absolute order.
  "timestamp": "2025-09-26T10:35:35.123Z",
  // [Required] ISO 8601 UTC timestamp.
  "type": "EVENT_TYPE",
  // [Required] Event type identifier.
  "payload": { ... }
  // [Required] Event-specific content.
}
```

### 7.2 Core Event Payloads (Payload Schemas)

### A. Run Lifecycle Events

`RUN_START`: Records the start of a run and initial state. (seq: 1)

```json
{
  "type": "RUN_START",
  "payload": {
    "run_id": "<RUN_ID>",
    "task": "The initial task description.",
    "agent_ref": "/path/to/Agent"
  }
}
```

`RUN_END`: Records the end of a run and final state.

```json
{
  "type": "RUN_END",
  "payload": {
    "status": "COMPLETED" // "COMPLETED", "FAILED", "INTERRUPTED"
  }
}
```

### B. T-A-O Loop Events

Thought and Action Request are recorded as independent events to clearly distinguish reasoning phases from execution phases.

`THOUGHT`: Records the thinking process generated by the LLM.

```json
{
  "type": "THOUGHT",
  "payload": {
    "content": "The reasoning text generated by the LLM.",
    // [Key] Associates to the exact LLM input/output payload saved in runtime_io/invocations/<UUID>/.
    "llm_invocation_ref": "<UUID>"
  }
}
```

**Design Consideration (`llm_invocation_ref`)**: This ID is crucial. It links the Thought event in the Journal to the exact LLM input/output payload stored in the `runtime_io/invocations/<UUID>/` directory (to be added in the CWD specification). This allows researchers to precisely audit how context engineering hooks affect LLM reasoning while keeping the Journal itself concise.

`ACTION_REQUEST`: Records tool invocations requested by the LLM. ("A" in T-A-O)

```json
{
  "type": "ACTION_REQUEST",
  "payload": {
    "action_id": "<UUID>", // [Key] Unique ID for associating this request with subsequent results
    "tool_name": "list_files",
    "tool_args": { "directory": "." },
    "resolved_command": "ls -F ." // The actual command line executed by the engine
  }
}
```

`ACTION_RESULT`: Records the result of tool execution. ("O" in T-A-O - Observation)

```json
{
  "type": "ACTION_RESULT",
  "payload": {
    "action_id": "<UUID>", // [Key] Associates back to the corresponding ACTION_REQUEST
    "status": "SUCCESS", // "SUCCESS", "FAILED", "ERROR"

    // [Key Distinction] The content actually injected into the next LLM context (may be truncated/summarized).
    // This ensures the integrity of the Journal as a source for context reconstruction.
    "observation_content": "The observation text provided to the LLM.",

    // [New] Reference to runtime_io/tool_executions/<ACTION_ID>/.
    "execution_ref": "<ACTION_ID>"
  }
}
```

### C. System and Audit Events

`SYSTEM_MESSAGE`: Used to record engine-level events that need to become part of the Agent's memory.

```bash
{
  "type": "SYSTEM_MESSAGE",
  "payload": {
    "level": "WARN", // INFO, WARN, ERROR
    "content": "e.g., 'pre_llm_req hook failed, proceeding with baseline context.'"
  }
}
```

`HOOK_EXECUTION_AUDIT`: Explicitly records lifecycle hook execution status.

```json
{
  "type": "HOOK_EXECUTION_AUDIT",
  "payload": {
    "hook_name": "pre_llm_req",
    "status": "SUCCESS", // SUCCESS | FAILED | SKIPPED
    // Provides relative path to the specific input/output directory in runtime_io
    "io_path_ref": "runtime_io/hooks/005_pre_llm_req/"
  }
}
```

## 8. Core Mechanisms and Workflows

### 8.1 Agent Orchestration: Zero-Copy Data Transfer (Zero-Copy Orchestration)

This architecture achieves efficient inter-Agent collaboration through shared working directories.

1. **Parent Agent Preparation:** Parent Agent (R1) creates a subdirectory for the sub-Agent (R2) within its own CWD (e.g., `./analyst_job`) and prepares input files.
2. **Parent Agent Invocation:** R1 calls `run_sub_agent(..., work_dir="./analyst_job")`.
3. **Engine Execution:** The parent engine converts the relative path to an absolute path, launches the sub-engine (R2) process, and sets its CWD to that absolute path.
4. **Sub-Agent Execution:** R2 reads input and writes output in that CWD. Its execution history is recorded in `./analyst_job/.delta/runs/<R2_ID>/`.
5. **Parent Agent Review:** R1 can immediately read R2's outputs from `./analyst_job`.

The entire process has no file copying or serialization overhead.

### 8.2 Stateless Execution and Context Reconstruction

Delta Engine's core process is stateless. `journal.jsonl` is the single source of truth. Before each LLM invocation, the engine rereads and reconstructs the complete conversation history from the CWD.

**Execution Flow Detailed:**

1. **Initialization:** `delta run` starts, creates `<RUN_ID>` directory, initializes `journal.jsonl`.
2. **Context Reconstruction (Read & Transform):** At the beginning of each loop cycle:
    - The engine **fully reads** the current `journal.jsonl` from disk.
    - The engine parses the event stream and, combined with the system prompt, constructs the dialogue context required by the LLM.
3. **LLM Invocation and Execution:** (If hooks are configured, they will be executed before this step, see 8.3). The engine calls the LLM and obtains new Thought and Action.
4. **State Persistence (Append):**
    - The engine immediately writes new T/A events to `journal.jsonl` in append mode.
    - The engine executes the Action.
    - The engine appends Observation (O) event to `journal.jsonl`.
5. **Loop:** Return to step 2.

**Design Advantages:**

- **Ultimate Robustness and Resumability:** After a process crash, execution can be perfectly resumed from the crash point by reading `journal.jsonl` (checkpoint recovery).
- **Transparency and Real-time Debugging:** Researchers can observe the Agent's thinking process in real-time through `tail -f journal.jsonl`.
- **Interactive Intervention:** Researchers can pause the engine, manually modify `journal.jsonl`, and then resume execution.
- Through `llm_invocation_ref` and `io_path_ref`, the connection between execution flow and underlying I/O details is achieved.

### 8.3 Case Study: pre_llm_req Context Engineering

This hook is used to dynamically modify the context sent to the LLM before invocation (e.g., inject CWD summary or compress history).

**Core Principle: Separation of Memory and Attention**

- **System Memory (journal.jsonl):** Complete, immutable objective event record (Ground Truth).
- **LLM Attention (Context Window):** Temporary, processed view.
- **Constraint:** Hooks can modify "attention" but must never cause "memory" to be rewritten.

**pre_llm_req API Contract (Specialized)**

```bash
<Step>_pre_llm_req/
├── input/
│   # [Core Input] Complete request payload prepared by the engine to send to LLM (P_base).
│   └── proposed_payload.json
└── output/
    # [Core Output] Payload the hook requires the engine to actually send (P_final) (complete override strategy).
    └── final_payload.json
```

**Integration Workflow (Payload Transformer)**

1. **Construct Baseline:** Engine reads `journal.jsonl` and constructs P_base.
2. **Hook Preparation:** Writes P_base to `input/proposed_payload.json`.
3. **Hook Execution:** Executes external hook command (CWD=Workspace). Hook performs transformation logic (inject summary or compress history) and writes P_final to `output/final_payload.json`.
4. **Payload Decision:** If hook succeeds, adopt P_final; otherwise, fall back to P_base.
5. **LLM Invocation:** Use the finally selected payload to call the LLM.

Auditability:

This design provides ultimate auditability. By comparing the payloads in input/ and output/, researchers can precisely understand what modifications the hook made.

## 9. Limitations and Future Evolution

### 9.1 Architectural Trade-offs and Risks

- **Performance Boundaries:** This architecture excels at handling file-based and batch-oriented task flows. However, for scenarios requiring high-frequency, low-latency, streaming interactions, its process-based startup and file I/O model may not be optimal.
- **Security Risks and Sandboxing:** The flexibility of "Everything is a Command" brings security risks. Developing a robust security sandbox execution environment is the project's highest priority task.
- **User Skill Requirements:** This design requires users to have deep understanding of command-line and filesystem concepts, a deliberate trade-off made to serve expert users.

### 9.2 Future Evolution Directions

The project's future evolution will strictly follow the principle of "keeping the core pure," adopting a layered evolution strategy:

1. **CWD Protocol Evolution:** Explore CWD Schemas (directory structure standardization), self-describing CWD (accelerate Agent environment awareness through `.delta/manifest.json`), and transactional operation tools (such as `atomic_write_file`) to enhance the robustness and expressiveness of CWD as a state bus.
2. **User-Space Extensions:** Evolve complex functionalities such as security sandboxes, advanced monitoring, and visual debugging interfaces as optional plugins on top of the core engine in a layered manner.
3. **Ecosystem Construction:** Explore managing and distributing Agents as NPM packages (leveraging the strategic advantage of the Node.js engine) to address version locking and dependency management issues, ensuring experimental reproducibility.
