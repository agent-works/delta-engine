# Delta Engine Architecture Design v1.4: Session Management

**Version**: 1.4.2
**Date**: October 1, 2025
**Status**: Design Specification (Implemented)
**Author**: Delta Engine Team

> **Implementation Note**: This design has been implemented in v1.4.2 using Unix Domain Sockets.
> The initial v1.4.0 implementation attempted a GNU Screen-based approach but encountered
> reliability issues. v1.4.2 uses a per-session holder process with Unix Socket IPC.

## Overview

v1.4 introduces **session management** capabilities to Delta Engine, enabling agents to interact with long-running, stateful processes (bash shells, SSH connections, REPL environments, interactive CLIs like Claude Code, etc.) while maintaining the core principle of stateless engine architecture.

**Key Additions:**
- New CLI tool: `delta-sessions` for managing interactive process sessions
- Support for any interactive command-line program
- Read/Write separation for asynchronous interaction patterns
- Persistent session state independent of Delta Engine runs
- Seamless integration with existing tool system

**Design Philosophy:**
- **Composition over Built-in** - Sessions are managed by an external tool, not engine internals
- **Process-Agnostic** - Support any interactive program, not just predefined types
- **Stateless Engine Preserved** - Session state lives in `.sessions/`, not in engine memory
- **Unix Philosophy** - Simple primitives (start, write, read, end) that compose into complex interactions

**Architecture (v1.4.2)**:
- **Unix Socket-based IPC** - Direct communication between CLI and holder processes
- **Per-session holder process** - Each session runs in its own detached Node.js process
- **Socket path optimization** - Sockets in `/tmp/` to avoid Unix socket path length limits (104 bytes on macOS)
- **node-pty integration** - Full PTY support for interactive programs

---

## 1. Motivation

### Problem Statement

Current Delta Engine architecture executes tools as **one-shot commands**:
```
Input → Tool Execution → Output → Tool Terminates
```

This model cannot handle:

1. **Long-running interactive programs** - bash shells, SSH, database clients, REPL environments
2. **Multi-turn interactions** - Claude Code, vim, interactive menus
3. **Streaming outputs** - `tail -f`, long-running builds, continuous monitoring
4. **State preservation across commands** - environment variables, working directory, session context

### Use Cases

#### Use Case 1: Interactive Shell
```
Agent needs to:
1. Start a bash shell
2. Set environment variables
3. Run multiple commands in that context
4. Access the cumulative state
```

#### Use Case 2: Claude Code Assistant
```
Agent needs to:
1. Launch Claude Code
2. Navigate interactive menus (arrow keys)
3. Send multiple queries
4. Read responses asynchronously
5. Maintain conversation context
```

#### Use Case 3: Long-Running Task Monitoring
```
Agent needs to:
1. Start `npm run build`
2. Periodically check progress
3. Continue with other tasks
4. Read final result when complete
```

#### Use Case 4: Database Exploration
```
Agent needs to:
1. Connect to PostgreSQL via `psql`
2. Run queries interactively
3. Inspect results
4. Maintain transaction context
```

---

## 2. Architecture Design

### 2.1 System Overview

```
┌─────────────────────────────────────────────────────┐
│                  Delta Engine                       │
│  (Stateless, Journal-based, Unchanged)              │
└────────────┬────────────────────────────────────────┘
             │
             │ Tool Calls
             │
             ▼
┌─────────────────────────────────────────────────────┐
│              delta-sessions CLI                      │
│  (New: Manages interactive processes)                │
│                                                      │
│  Commands: start, write, write-key, read,           │
│            end, list, status, cleanup               │
└────────────┬────────────────────────────────────────┘
             │
             │ Process Management
             │
             ▼
┌─────────────────────────────────────────────────────┐
│          Interactive Processes (PTY)                 │
│  bash, ssh, psql, python, claude, node, etc.        │
└─────────────────────────────────────────────────────┘
```

### 2.2 Component Responsibilities

#### Delta Engine
- Remains **stateless** and **session-unaware**
- Treats `delta-sessions` as a regular external tool
- Records session tool calls in journal (ACTION_REQUEST/ACTION_RESULT)
- No special handling of session lifecycle

#### delta-sessions CLI
- **Lifecycle Management** - Start, terminate, cleanup sessions
- **I/O Management** - Write input, read output, buffer management
- **State Persistence** - Session metadata in `.sessions/` directory
- **Process Health** - Monitor and detect dead processes
- **Escape Sequence Handling** - Parse control characters and key codes

#### Session Storage (`.sessions/`)
- Independent of `.delta/` (Delta Engine state)
- Survives across `delta run` invocations
- Contains session metadata, PIDs, output logs

---

## 3. Directory Structure

### 3.1 Session State Location

```
<AGENT_WORKSPACE>/
├── .delta/                    # Delta Engine state (unchanged)
│   ├── VERSION
│   ├── LATEST
│   └── {run_id}/
│       ├── journal.jsonl
│       ├── metadata.json
│       └── io/
└── .sessions/                 # Session management state (NEW)
    ├── index.json             # Session registry
    ├── sess_abc123/           # Individual session directory
    │   ├── metadata.json      # {session_id, command, pid, created_at, status}
    │   ├── pid                # Process ID (for quick checks)
    │   ├── output.log         # Complete output history (persistent)
    │   └── input.log          # Input history (optional, for debugging)
    └── sess_def456/
        └── ...
```

### 3.2 Session Metadata Format

**`.sessions/sess_abc123/metadata.json`**:
```json
{
  "session_id": "sess_abc123",
  "command": ["bash", "-i"],
  "pid": 12345,
  "created_at": "2025-10-01T10:30:00Z",
  "last_accessed_at": "2025-10-01T10:35:00Z",
  "status": "running",
  "sessions_dir": "/path/to/.sessions"
}
```

**`.sessions/index.json`**:
```json
{
  "sessions": [
    {
      "session_id": "sess_abc123",
      "command": "bash -i",
      "status": "running",
      "created_at": "2025-10-01T10:30:00Z"
    }
  ],
  "last_cleanup_at": "2025-10-01T09:00:00Z"
}
```

---

## 4. CLI Interface Specification

### 4.1 Command Overview

```bash
# Lifecycle
delta-sessions start <command> [args...]     # Start interactive process
delta-sessions end <session_id>              # Terminate session
delta-sessions cleanup                       # Remove dead sessions

# Interaction
delta-sessions write <session_id>            # Send input (from stdin)
delta-sessions write-key <session_id> <key>  # Send control key (semantic)
delta-sessions read <session_id> [options]   # Read output

# Management
delta-sessions list                          # List all sessions
delta-sessions status <session_id>           # Check session health

# Global Options
--sessions-dir <path>   # Override default .sessions location
--help                  # Show help
--version               # Show version
```

### 4.2 Command Details

#### `start` - Start a Session

**Syntax:**
```bash
delta-sessions start <command> [args...]
```

**Examples:**
```bash
delta-sessions start bash -i
delta-sessions start ssh user@example.com
delta-sessions start psql -U postgres mydb
delta-sessions start claude --project .
delta-sessions start python3 -i
```

**Output (JSON to stdout):**
```json
{
  "session_id": "sess_abc123",
  "status": "running",
  "pid": 12345,
  "command": ["bash", "-i"]
}
```

**Error Handling:**
- If command fails to start → exit code 1, error to stderr

---

#### `write` - Send Input

**Syntax:**
```bash
delta-sessions write <session_id>
# Reads input from stdin
```

**Features:**
- Supports **escape sequence parsing**:
  - `\n` → newline
  - `\t` → tab
  - `\x1b[A` → up arrow
  - `\x03` → Ctrl+C
  - `\x1b` → ESC
  - etc.

**Examples:**
```bash
# Send command with newline
echo -e "ls -la\n" | delta-sessions write sess_abc123

# Send arrow key (down)
echo -e "\x1b[B" | delta-sessions write sess_abc123

# Send Ctrl+C
printf "\x03" | delta-sessions write sess_abc123
```

**Output (JSON):**
```json
{
  "status": "sent",
  "bytes": 7,
  "session_id": "sess_abc123"
}
```

**Error Handling:**
- Session not found → exit 1
- Session dead → exit 1, error message

---

#### `write-key` - Send Semantic Key

**Syntax:**
```bash
delta-sessions write-key <session_id> <key_name>
```

**Supported Keys:**

| Category | Keys |
|----------|------|
| **Navigation** | `arrow_up`, `arrow_down`, `arrow_left`, `arrow_right` |
| **Confirmation** | `enter`, `tab`, `escape`, `space`, `backspace` |
| **Control** | `ctrl+a` through `ctrl+z` |
| **Function** | `f1` through `f12` |
| **Editing** | `home`, `end`, `page_up`, `page_down`, `delete`, `insert` |

**Examples:**
```bash
delta-sessions write-key sess_abc123 arrow_down
delta-sessions write-key sess_abc123 enter
delta-sessions write-key sess_abc123 ctrl+c
delta-sessions write-key sess_abc123 escape
```

**Output (JSON):**
```json
{
  "status": "sent",
  "key": "arrow_down",
  "session_id": "sess_abc123"
}
```

**Rationale:**
- **Semantic clarity** - `arrow_down` more readable than `\x1b[B` in journal logs
- **Error prevention** - Reduces LLM mistakes with escape sequences
- **Backwards compatible** - `write` still supports raw escape sequences

---

#### `read` - Read Output

**Syntax:**
```bash
delta-sessions read <session_id> [options]
```

**Options:**

| Option | Description | Default |
|--------|-------------|---------|
| `--timeout <ms>` | Wait N milliseconds before returning | 0 (immediate) |
| `--wait` | Block until output available | false |
| `--follow` | Stream output continuously (like `tail -f`) | false |
| `--lines <N>` | Return only last N lines | all |

**Behavior Modes:**

1. **Immediate Read** (default):
   ```bash
   delta-sessions read sess_abc123
   # Returns current buffer, clears it
   ```

2. **Timeout Read**:
   ```bash
   delta-sessions read sess_abc123 --timeout 3000
   # Waits up to 3 seconds for output
   ```

3. **Blocking Read**:
   ```bash
   delta-sessions read sess_abc123 --wait
   # Blocks until output appears
   ```

4. **Streaming Read**:
   ```bash
   delta-sessions read sess_abc123 --follow
   # Continuously outputs until Ctrl+C
   ```

**Output (stdout - raw text):**
```
$ ls -la
total 48
drwxr-xr-x  12 user  staff   384 Oct  1 10:30 .
drwxr-xr-x  20 user  staff   640 Oct  1 10:25 ..
...
```

**Error Handling:**
- Session not found → exit 1
- Session dead → exit 1, error to stderr

---

#### `end` - Terminate Session

**Syntax:**
```bash
delta-sessions end <session_id>
```

**Behavior:**
- Sends SIGTERM to process
- Waits up to 5 seconds for graceful shutdown
- Sends SIGKILL if process doesn't terminate
- Removes session directory

**Output (JSON):**
```json
{
  "status": "terminated",
  "session_id": "sess_abc123"
}
```

---

#### `list` - List Sessions

**Syntax:**
```bash
delta-sessions list
```

**Output (JSON array):**
```json
[
  {
    "session_id": "sess_abc123",
    "command": "bash -i",
    "status": "running",
    "pid": 12345,
    "created_at": "2025-10-01T10:30:00Z",
    "last_accessed_at": "2025-10-01T10:35:00Z"
  },
  {
    "session_id": "sess_def456",
    "command": "ssh user@host",
    "status": "dead",
    "pid": 12346,
    "created_at": "2025-10-01T10:00:00Z",
    "last_accessed_at": "2025-10-01T10:10:00Z"
  }
]
```

---

#### `status` - Check Session Health

**Syntax:**
```bash
delta-sessions status <session_id>
```

**Output (JSON):**
```json
{
  "session_id": "sess_abc123",
  "status": "running",
  "pid": 12345,
  "alive": true,
  "uptime_seconds": 300,
  "command": "bash -i"
}
```

**Status Values:**
- `running` - Process is alive
- `dead` - Process terminated

---

#### `cleanup` - Remove Dead Sessions

**Syntax:**
```bash
delta-sessions cleanup
```

**Behavior:**
- Scans all sessions in `.sessions/`
- Checks if PID is alive
- Removes directories for dead sessions

**Output (JSON):**
```json
{
  "cleaned": ["sess_abc123", "sess_def456"],
  "remaining": ["sess_xyz789"]
}
```

---

## 5. Agent Integration

### 5.1 Tool Configuration

**Example: Interactive Shell Agent**

**`examples/2-core-features/interactive-shell/config.yaml`**:
```yaml
name: interactive-shell
version: 1.0.0
description: Agent with persistent bash shell session

llm:
  model: gpt-4o
  temperature: 0.7

tools:
  # Start a session
  - name: shell_start
    description: "Start a persistent bash shell session"
    command: [delta-sessions, start, bash, "-i"]
    parameters: []

  # Send text input
  - name: shell_write
    description: "Send input to the shell (supports escape sequences)"
    command: [delta-sessions, write]
    parameters:
      - name: session_id
        type: string
        description: "Session ID from shell_start"
        inject_as: argument
      - name: input
        type: string
        description: "Input to send (use \\n for newline, \\x1b[A for up arrow)"
        inject_as: stdin

  # Send control keys (recommended for navigation)
  - name: shell_send_key
    description: |
      Send a control key to the shell session.
      Supported keys: arrow_up, arrow_down, arrow_left, arrow_right,
      enter, tab, escape, space, backspace, ctrl+c, ctrl+d, home, end
    command: [delta-sessions, write-key]
    parameters:
      - name: session_id
        type: string
        inject_as: argument
      - name: key
        type: string
        description: "Key name (e.g., 'arrow_down', 'enter', 'ctrl+c')"
        inject_as: argument

  # Read output
  - name: shell_read
    description: "Read output from the shell session"
    command: [delta-sessions, read]
    parameters:
      - name: session_id
        type: string
        inject_as: argument
      - name: timeout_ms
        type: number
        description: "Wait timeout in milliseconds (0 = immediate)"
        inject_as: option
        option_name: --timeout

  # End session
  - name: shell_end
    description: "Terminate the shell session"
    command: [delta-sessions, end]
    parameters:
      - name: session_id
        type: string
        inject_as: argument

  # List sessions
  - name: shell_list
    description: "List all active sessions"
    command: [delta-sessions, list]
    parameters: []
```

### 5.2 Agent Workflow Example

**Task**: "List files, then check disk usage"

**Agent Execution:**

```
Thought: I need a persistent shell to run multiple commands.

Action: shell_start()
Result: {"session_id": "sess_abc123", "status": "running"}

---

Thought: Read the initial prompt to confirm shell is ready.

Action: shell_read(sess_abc123, timeout_ms=1000)
Result: "user@host:~/project$ "

---

Thought: Send the 'ls -la' command.

Action: shell_write(sess_abc123, "ls -la\n")
Result: {"status": "sent"}

Action: shell_read(sess_abc123, timeout_ms=2000)
Result: "total 48\ndrwxr-xr-x  12 user  staff  384 Oct  1 10:30 .\n..."

---

Thought: Now check disk usage in the same shell context.

Action: shell_write(sess_abc123, "df -h .\n")
Result: {"status": "sent"}

Action: shell_read(sess_abc123, timeout_ms=2000)
Result: "Filesystem  Size  Used  Avail  Use%  Mounted on\n/dev/sda1   50G   30G   18G   63%  /"

---

Thought: Task complete, clean up the session.

Action: shell_end(sess_abc123)
Result: {"status": "terminated"}
```

**Journal Log (excerpt)**:
```jsonl
{"type":"ACTION_REQUEST","tool_name":"shell_start","tool_args":{},"timestamp":"..."}
{"type":"ACTION_RESULT","observation_content":"{\"session_id\":\"sess_abc123\"}","timestamp":"..."}
{"type":"ACTION_REQUEST","tool_name":"shell_write","tool_args":{"session_id":"sess_abc123","input":"ls -la\\n"},"timestamp":"..."}
{"type":"ACTION_RESULT","observation_content":"total 48\\ndrwxr-xr-x...","timestamp":"..."}
```

---

## 6. Technical Implementation

### 6.1 Core Technologies

**Node.js PTY (node-pty)**

**Why PTY?**
- Provides a **real pseudo-terminal** (PTY), not just pipes
- Handles ANSI escape sequences correctly
- Supports interactive programs (vim, top, Claude Code, menus)
- Processes think they're running in a real terminal

**Alternative considered**: `child_process` + pipes
- ❌ Not a true terminal (no ANSI support, no job control)
- ❌ Interactive programs may behave incorrectly
- ✅ No native dependencies

**Decision**: Use `node-pty` for full compatibility

### 6.2 Module Structure

```
src/sessions/
├── types.ts              # TypeScript interfaces and Zod schemas
├── manager.ts            # SessionManager (high-level API)
├── session.ts            # Session class (abstraction)
├── bash-session.ts       # BashSession implementation (node-pty wrapper)
├── storage.ts            # Metadata persistence (JSON files)
├── escape-parser.ts      # Escape sequence parsing for write command
└── key-codes.ts          # Key name → control sequence mapping

src/
├── sessions-cli.ts       # CLI entry point for delta-sessions
└── index.ts              # Existing delta CLI entry point (unchanged)
```

### 6.3 Key Classes

**SessionManager**

```typescript
export class SessionManager {
  constructor(private config: { sessions_dir: string });

  async createSession(command: string[], args: string[]): Promise<string>;
  async getSession(sessionId: string): Promise<Session | null>;
  async listSessions(): Promise<SessionMetadata[]>;
  async terminateSession(sessionId: string): Promise<void>;
  async cleanup(): Promise<string[]>;
}
```

**Session**

```typescript
export class Session {
  constructor(
    private sessionId: string,
    private sessionDir: string,
    private ptyProcess: IPty
  );

  write(input: string): void;
  read(): string;
  readWithTimeout(timeoutMs: number): Promise<string>;
  streamOutput(): AsyncGenerator<string>;
  isAlive(): boolean;
  getPid(): number;
  getMetadata(): SessionMetadata;
  terminate(): Promise<void>;
}
```

### 6.4 Escape Sequence Parsing

**Implementation in `escape-parser.ts`:**

```typescript
export function parseEscapeSequences(input: string): string {
  return input
    // Standard escapes
    .replace(/\\n/g, '\n')
    .replace(/\\r/g, '\r')
    .replace(/\\t/g, '\t')
    .replace(/\\b/g, '\b')
    .replace(/\\f/g, '\f')
    .replace(/\\v/g, '\v')
    // Hex escapes (\x1b)
    .replace(/\\x([0-9a-fA-F]{2})/g, (_, hex) =>
      String.fromCharCode(parseInt(hex, 16))
    )
    // Unicode escapes (\u001b)
    .replace(/\\u([0-9a-fA-F]{4})/g, (_, hex) =>
      String.fromCharCode(parseInt(hex, 16))
    )
    // Backslash escape
    .replace(/\\\\/g, '\\');
}
```

### 6.5 Key Code Mapping

**Implementation in `key-codes.ts`:**

```typescript
export const KEY_CODES: Record<string, string> = {
  // Navigation
  arrow_up: '\x1b[A',
  arrow_down: '\x1b[B',
  arrow_left: '\x1b[D',
  arrow_right: '\x1b[C',

  // Confirmation
  enter: '\n',
  tab: '\t',
  escape: '\x1b',
  space: ' ',
  backspace: '\x7f',

  // Control keys (Ctrl+A = 0x01, Ctrl+Z = 0x1A)
  'ctrl+a': '\x01',
  'ctrl+b': '\x02',
  'ctrl+c': '\x03',
  // ... through ctrl+z

  // Function keys
  f1: '\x1bOP',
  f2: '\x1bOQ',
  // ... through f12

  // Editing
  home: '\x1b[H',
  end: '\x1b[F',
  page_up: '\x1b[5~',
  page_down: '\x1b[6~',
  delete: '\x1b[3~',
  insert: '\x1b[2~',
};
```

---

## 7. Error Handling and Resilience

### 7.1 Session Lifecycle States

```
          start
    ┌──────────────┐
    │              │
    ▼              │
[RUNNING] ────────┤
    │              │
    │ (process     │
    │  dies)       │
    │              │
    ▼              │
 [DEAD] ───────────┘
                   end/cleanup
```

### 7.2 Error Scenarios

**Scenario 1: Process Dies During Execution**

```
Agent calls: shell_write(sess_abc, "command\n")
→ delta-sessions checks PID
→ Process not found
→ Returns error to stdout:
  {"error": "Session sess_abc is dead"}
→ Agent sees error in ACTION_RESULT
→ Agent decides: restart session or fail gracefully
```

**Scenario 2: Session Not Found**

```
Agent calls: shell_read(sess_xyz)
→ Session directory doesn't exist
→ Exit code 1, stderr: "Session sess_xyz not found"
→ Agent receives error
```

**Scenario 3: Delta Engine Crash**

```
1. Agent created session sess_abc
2. Delta run crashes (Ctrl+C, system crash, etc.)
3. Session process keeps running (independent)
4. User restarts: delta run (resume)
5. Engine rebuilds state from journal
6. Agent sees it created sess_abc in journal
7. Agent calls shell_read(sess_abc)
8. delta-sessions checks: PID still alive? → Yes
9. Agent continues seamlessly
```

**Scenario 4: Session Orphaned**

```
1. Agent creates session sess_abc
2. Delta run completes/crashes
3. Session process still running (orphaned)
4. User runs: delta-sessions cleanup
5. Tool scans .sessions/, finds orphaned sessions
6. Terminates processes, removes directories
```

### 7.3 Cleanup Strategies

**Automatic Cleanup (Optional)**

Agent can include cleanup hook in `config.yaml`:

```yaml
hooks:
  on_error:
    command: [delta-sessions, cleanup]
```

**Manual Cleanup**

User can run:
```bash
delta-sessions cleanup
# Or from agent workspace:
cd workspaces/W001 && delta-sessions cleanup
```

**Background Cleanup (Future)**

Cron job or systemd service:
```bash
# Run every hour
0 * * * * cd /path/to/agents && find . -name .sessions -exec delta-sessions --sessions-dir {} cleanup \;
```

---

## 8. Design Decisions and Rationale

### 8.1 Why External Tool, Not Engine Feature?

**Decision**: Implement as `delta-sessions` CLI, not built into engine.

**Rationale**:
- ✅ **Preserves Stateless Core** - Engine doesn't track session state
- ✅ **Composition over Monolith** - Sessions are a capability, not a requirement
- ✅ **Independent Evolution** - Can upgrade `delta-sessions` without changing engine
- ✅ **Reusable** - Other projects can use `delta-sessions` standalone
- ✅ **Testable** - Sessions can be tested independently

**Alternative Rejected**: Add `stateful: true` flag to tools in `config.yaml`
- ❌ Engine needs to understand "stateful" semantics (violates philosophy)
- ❌ Engine must track session lifecycle (violates stateless core)
- ❌ Adds complexity to engine internals

### 8.2 Why `.sessions/` Instead of `.delta/sessions/`?

**Decision**: Store sessions in `.sessions/`, separate from `.delta/`.

**Rationale**:
- ✅ **Clear Separation** - `.delta/` is engine state, `.sessions/` is process state
- ✅ **Independent Lifecycle** - Sessions survive across `delta run` invocations
- ✅ **Cleanup Independence** - Can remove `.delta/` without affecting sessions
- ✅ **Conceptual Clarity** - Different concerns, different directories

### 8.3 Why Both `write` and `write-key`?

**Decision**: Provide both commands.

**Rationale**:
- ✅ **`write-key` for clarity** - Semantic names prevent LLM errors
- ✅ **`write` for flexibility** - Power users can send arbitrary sequences
- ✅ **Journal readability** - `"key": "arrow_down"` clearer than `"input": "\\x1b[B"`
- ✅ **Backwards compatible** - If agent doesn't configure `write-key`, `write` still works

### 8.4 Why node-pty Instead of Pipes?

**Decision**: Use `node-pty` for PTY-based sessions.

**Rationale**:
- ✅ **True Terminal** - Programs behave correctly (ANSI, job control)
- ✅ **Interactive Programs** - vim, top, Claude Code, menus work properly
- ✅ **Industry Standard** - Used by VS Code, Hyper, terminals everywhere
- ⚠️ **Native Dependency** - Acceptable trade-off (prebuilt binaries available)

**Alternative Rejected**: `child_process.spawn()` with stdio pipes
- ❌ Not a real terminal
- ❌ Interactive programs detect and may refuse to run

### 8.5 Why Not Support Remote Sessions (SSH to Server)?

**Decision**: v1.4 supports local processes only. Remote sessions deferred.

**Rationale**:
- ✅ **Simplicity** - Local PTY is straightforward
- ✅ **80% Use Case** - Most agents need local shells/REPLs
- ⏰ **Future Extension** - Can add remote session types later (v1.5+)

**Future Design**:
```bash
delta-sessions start --type remote ssh://user@host
delta-sessions start --type docker container_id bash
```

---

## 9. Examples and Use Cases

### 9.1 Example: Claude Code Integration

**Agent Goal**: Use Claude Code to analyze codebase and suggest refactorings.

**Agent Config** (`config.yaml`):
```yaml
tools:
  - name: claude_start
    command: [delta-sessions, start, claude, --project, .]
  - name: claude_send
    command: [delta-sessions, write]
    parameters:
      - name: session_id
        inject_as: argument
      - name: message
        inject_as: stdin
  - name: claude_send_key
    command: [delta-sessions, write-key]
    parameters:
      - name: session_id
        inject_as: argument
      - name: key
        inject_as: argument
  - name: claude_read
    command: [delta-sessions, read]
    parameters:
      - name: session_id
        inject_as: argument
      - name: timeout_ms
        inject_as: option
        option_name: --timeout
  - name: claude_end
    command: [delta-sessions, end]
    parameters:
      - name: session_id
        inject_as: argument
```

**Agent Workflow**:

```
1. Start Claude Code session
   Action: claude_start()
   Result: {"session_id": "sess_claude_001"}

2. Read welcome screen
   Action: claude_read(sess_claude_001, timeout_ms=2000)
   Result: "Claude Code v1.4\n? Select mode:\n❯ Plan Mode\n  Execute Mode\n  Exit"

3. Navigate to Execute Mode (down arrow)
   Action: claude_send_key(sess_claude_001, "arrow_down")

4. Confirm selection (Enter)
   Action: claude_send_key(sess_claude_001, "enter")

5. Read prompt
   Action: claude_read(sess_claude_001, timeout_ms=1000)
   Result: "Claude Code > "

6. Send analysis request
   Action: claude_send(sess_claude_001, "Analyze src/engine.ts and suggest 3 optimizations")
   Action: claude_send_key(sess_claude_001, "enter")

7. Read Claude's response
   Action: claude_read(sess_claude_001, timeout_ms=15000)
   Result: "Analysis of src/engine.ts:\n1. Consider caching journal reads...\n2. Batch file I/O operations...\n3. Use async iterators for message streaming..."

8. Ask follow-up
   Action: claude_send(sess_claude_001, "Show me code for optimization #1")
   Action: claude_send_key(sess_claude_001, "enter")

9. Read implementation
   Action: claude_read(sess_claude_001, timeout_ms=10000)
   Result: "Here's the code for journal caching:\n```typescript\n..."

10. End session
    Action: claude_end(sess_claude_001)
```

---

## 10. Testing Strategy

### 10.1 Unit Tests

**Location**: `tests/unit/sessions/`

**Coverage**:
- `manager.test.ts` - SessionManager CRUD operations
- `session.test.ts` - Session I/O, buffering, timeout logic
- `escape-parser.test.ts` - Escape sequence parsing edge cases
- `key-codes.test.ts` - Key name validation
- `storage.test.ts` - Metadata persistence

**Example Test**:
```typescript
describe('SessionManager', () => {
  it('should create and retrieve a session', async () => {
    const manager = new SessionManager({ sessions_dir: '/tmp/test-sessions' });

    const sessionId = await manager.createSession(['bash', '-i']);
    expect(sessionId).toMatch(/^sess_/);

    const session = await manager.getSession(sessionId);
    expect(session).not.toBeNull();
    expect(session!.isAlive()).toBe(true);
  });
});
```

### 10.2 Integration Tests

**Location**: `tests/integration/sessions/`

**Coverage**:
- `basic-workflow.test.ts` - start → write → read → end
- `interactive-menu.test.ts` - Simulate menu navigation with arrow keys
- `dead-session-detection.test.ts` - Kill process, verify detection
- `cleanup.test.ts` - Create multiple sessions, cleanup orphaned
- `long-running-task.test.ts` - Stream output from long command
- `concurrent-sessions.test.ts` - Multiple sessions in parallel

**Example Test**:
```typescript
describe('Session Workflow', () => {
  it('should handle bash command execution', async () => {
    // Start session
    const { session_id } = await execCli(['start', 'bash', '-i']);

    // Send command
    await execCli(['write', session_id], { stdin: 'echo "hello"\n' });

    // Read output
    const output = await execCli(['read', session_id, '--timeout', '2000']);
    expect(output).toContain('hello');

    // Cleanup
    await execCli(['end', session_id]);
  });
});
```

### 10.3 End-to-End Tests

**Location**: `tests/e2e/`

**Coverage**:
- `claude-code-interaction.test.ts` - Full Claude Code workflow (if available)
- `python-repl.test.ts` - Python REPL multi-turn interaction
- `vim-editing.test.ts` - Launch vim, edit file, save, exit

---

## 11. Documentation Requirements

### 11.1 User-Facing Documentation

**`docs/guides/session-management.md`**:
- What are sessions and when to use them
- Quick start guide
- Common patterns (shell, REPL, interactive CLIs)
- Troubleshooting

**`docs/api/delta-sessions.md`**:
- Complete CLI reference
- All commands with examples
- Exit codes and error messages

**Example Agent READMEs**:
- `examples/2-core-features/interactive-shell/README.md`
- `examples/claude-assistant/README.md`
- `examples/2-core-features/python-repl/README.md`

### 11.2 Control Character Quick Reference

**Included in agent system_prompt templates**:

```markdown
# Terminal Control Characters Quick Reference

## Navigation Keys
- Up Arrow: \x1b[A
- Down Arrow: \x1b[B
- Left Arrow: \x1b[D
- Right Arrow: \x1b[C

## Common Keys
- Enter: \n
- Tab: \t
- Escape: \x1b
- Backspace: \x7f
- Space: (space character)

## Control Keys
- Ctrl+C (Interrupt): \x03
- Ctrl+D (EOF): \x04
- Ctrl+Z (Suspend): \x1a

## Usage with shell_send_key (Recommended)
Instead of using escape sequences, use the shell_send_key tool with semantic names:
- shell_send_key(session_id, "arrow_down")
- shell_send_key(session_id, "enter")
- shell_send_key(session_id, "ctrl+c")
```

---

## 12. Migration and Compatibility

### 12.1 Backwards Compatibility

**Impact**: None - sessions are a new feature.

**Existing agents**: Continue to work without modification.

**Opt-in**: Agents must explicitly configure session tools in `config.yaml`.

### 12.2 Version Bump

**Current**: v1.3.0
**Target**: v1.4.0 (minor version bump - new features, no breaking changes)

**Changelog**:
```
## v1.4.0 - Session Management

### Added
- New CLI tool: `delta-sessions` for managing interactive process sessions
- Support for long-running, stateful processes (bash, ssh, REPL, interactive CLIs)
- Read/Write separation for asynchronous interactions
- Semantic key input via `write-key` command
- Session lifecycle management (start, end, cleanup)
- Session health monitoring and dead process detection

### Documentation
- docs/architecture/v1.4-sessions-design.md - Complete specification
- docs/guides/session-management.md - User guide
- docs/api/delta-sessions.md - CLI reference
- Example agents: interactive-shell, claude-assistant
```

---

## 13. Future Extensions (Out of Scope for v1.4)

### 13.1 Remote Sessions
```bash
delta-sessions start --type ssh ssh://user@host
delta-sessions start --type docker container_id bash
```

### 13.2 Session Recording/Replay
```bash
delta-sessions start --record bash
# Later:
delta-sessions replay sess_abc123
```

### 13.3 Session Sharing Across Agents
```bash
# Agent A creates session
delta-sessions start bash

# Agent B attaches to same session
delta-sessions attach sess_abc123
```

### 13.4 Session Persistence/Checkpointing
```bash
# Save session state
delta-sessions checkpoint sess_abc123

# Restore session
delta-sessions restore sess_abc123_checkpoint_001
```

---

## 14. Summary

**v1.4 introduces session management** to Delta Engine through a new external CLI tool (`delta-sessions`), enabling agents to interact with long-running, stateful processes while preserving the engine's stateless core architecture.

**Key Principles**:
- **Composition over built-in** - Sessions are an external capability
- **Process-agnostic** - Support any interactive program
- **Read/Write separation** - Asynchronous interaction patterns
- **Stateless engine preserved** - No engine changes required

**Benefits**:
- ✅ Agents can now use bash shells, SSH, database clients, REPLs, Claude Code, etc.
- ✅ Multi-turn interactions with stateful context
- ✅ Monitoring of long-running tasks
- ✅ Control over interactive menus and TUI applications

**Implementation**:
- ~3000 lines of new code in `src/sessions/`
- New CLI entry point: `src/sessions-cli.ts`
- No changes to existing Delta Engine core
- Comprehensive test coverage (unit + integration + e2e)

**Timeline**: 8-12 days for complete implementation (see implementation plan document).

---

## 10. Implementation History

### v1.4.0 - GNU Screen Approach (Failed)

**Attempted Architecture**:
- Used GNU Screen for session management
- `screen -dmS` to create detached sessions
- `screen -S <name> -X hardcopy` to capture output
- `screen -S <name> -X stuff` to send input

**Problems Encountered**:
- `hardcopy` produces empty files when session is detached
- No reliable way to read output from detached screen sessions
- Complex setup and platform-specific issues
- Poor error handling and debugging

**Result**: Abandoned after POC validation failures (Oct 1, 2025).

### v1.4.1 - (Skipped)

Never implemented. Version number skipped to avoid confusion.

### v1.4.2 - Unix Socket Approach (Successful) ✅

**Final Architecture**:
- **Per-session holder process**: Each session = 1 detached Node.js process
- **Unix Domain Socket IPC**: Direct JSON protocol communication
- **node-pty for PTY**: Full terminal emulation support
- **Socket path optimization**: Sockets in `/tmp/delta-sock-{sessionId}.sock` to avoid 104-byte path length limit on macOS

**Key Components**:
1. **holder.ts** (191 lines): Detached process managing PTY + socket server
2. **socket-utils.ts** (132 lines): Socket communication and stale detection
3. **session.ts** (310 lines): Session class with create/reconnect methods
4. **manager.ts** (252 lines): High-level API with cross-process support
5. **sessions-cli.ts** (428 lines): CLI interface with 8 commands

**Validation Process**:
- 9 POC test scripts in `investigation/` directory
- Validated: holder crash detection, stale socket cleanup, concurrent access, zombie prevention, large data transfer
- See `investigation/FINAL_POC_README.md` for complete validation report

**Result**: ✅ Successfully implemented and tested (Oct 1, 2025). All functionality working including:
- Session creation/termination
- Cross-process reconnection
- Write/read operations
- List and cleanup commands
- Full E2E agent workflows

**Socket Path Solution**:
- **Problem**: Unix socket paths limited to 104 bytes on macOS
- **Solution**: Store socket in `/tmp/delta-sock-{sessionId}.sock` (42 bytes)
- **Metadata**: Remains in `$CWD/.sessions/{sessionId}/` (preserves original design)
- **Impact**: Transparent to users, no API changes
