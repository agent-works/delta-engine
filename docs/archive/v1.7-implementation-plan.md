# Delta Engine v1.7: Tool Simplification Implementation Plan

**Version**: 1.0.0
**Date**: October 11, 2025
**Status**: Approved for Implementation
**Related Spec**: [v1.7-tool-simplification.md](./v1.7-tool-simplification.md)

---

## Executive Summary

This document provides a comprehensive implementation roadmap for Delta Engine v1.7's tool configuration simplification feature. The implementation introduces `exec:` and `shell:` syntax sugar while maintaining 100% backward compatibility with existing `command:` array syntax.

**Key Objectives:**
- Reduce cognitive load for 80% of common tool definitions
- Maintain security through "secure by default" design
- Provide full transparency via `delta tool expand` command
- Achieve 100% backward compatibility

**Timeline**: 2-3 weeks (15-20 development hours)
**Risk Level**: Medium (new parsing logic, security-critical)
**Priority**: P1 (High - enables faster prototyping)

---

## Table of Contents

1. [Current State Analysis](#1-current-state-analysis)
2. [Implementation Phases](#2-implementation-phases)
3. [Phase Details](#3-phase-details)
4. [Security Verification Strategy](#4-security-verification-strategy)
5. [Risk Assessment and Mitigation](#5-risk-assessment-and-mitigation)
6. [Success Criteria](#6-success-criteria)
7. [Timeline and Milestones](#7-timeline-and-milestones)
8. [Testing Strategy](#8-testing-strategy)
9. [Documentation Checklist](#9-documentation-checklist)
10. [Rollback Plan](#10-rollback-plan)

---

## 1. Current State Analysis

### 1.1 Existing Components

**Core Files:**
- `src/types.ts` (line 51): `ToolDefinitionSchema` - Zod schema for tool validation
- `src/executor.ts` (line 1): Tool execution with 3 injection types (argument, stdin, option)
- `src/config.ts` (line 13): Config loading with `loadAndValidateAgent()`
- `src/tool_schema.ts`: Internal ‚Üí OpenAI schema conversion

**Strengths:**
- ‚úÖ Robust validation with Zod
- ‚úÖ Secure parameter injection (3 modes)
- ‚úÖ Comprehensive test suite (unit + integration + e2e)
- ‚úÖ Stateless core architecture

**Gaps:**
- ‚ùå No support for `exec:` or `shell:` syntax
- ‚ùå No ToolExpander module for syntax sugar processing
- ‚ùå No validation for shell metacharacters
- ‚ùå No `delta tool expand` CLI command

### 1.2 Architecture Constraints

**Must Preserve:**
1. **Stateless Core**: All tool expansion happens at config load time
2. **Zod Validation**: All schemas must use Zod for type safety
3. **Three Injection Types**: `argument`, `stdin`, `option` must remain unchanged
4. **Backward Compatibility**: Existing agents must work without modification

**Integration Points:**
- Config loading (`config.ts:loadAndValidateAgent`)
- Type system (`types.ts:ToolDefinitionSchema`)
- Executor logic (`executor.ts:executeTool`) - no changes needed
- CLI entry point (`src/index.ts` or `src/cli.ts`)

---

## 2. Implementation Phases

**Overview:**

```
Phase 1: Type System Extension (2-3h)
   ‚Üì
Phase 2: ToolExpander Module (4-5h)  ‚Üê Core Logic
   ‚Üì
Phase 3: Config Integration (2h)
   ‚Üì
Phase 4: CLI Transparency Tool (2h)
   ‚Üì
Phase 5: Comprehensive Testing (3-4h)
   ‚Üì
Phase 6: Documentation & ADR (2h)
```

**Total Estimate**: 15-18 hours

---

## 3. Phase Details

### Phase 1: Type System Extension (2-3 hours)

**Objective**: Define Zod schemas for v1.7 simplified syntax

**Files to Modify:**
- `src/types.ts`

**Tasks:**

#### Task 1.1: Create Simplified Syntax Schemas (45 min)

```typescript
// src/types.ts

// Exec mode tool configuration
export const ExecToolConfigSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  exec: z.string(), // Template string with ${param}
  stdin: z.string().optional(), // Optional stdin parameter name
  parameters: z.array(ToolParameterSchema).optional(), // Override/supplement
});

// Shell mode tool configuration
export const ShellToolConfigSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  shell: z.string(), // Template with ${param} or ${param:raw}
  stdin: z.string().optional(),
  parameters: z.array(ToolParameterSchema).optional(),
});

// Legacy full configuration (existing)
export const LegacyToolConfigSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  command: z.array(z.string()).min(1),
  parameters: z.array(ToolParameterSchema),
});

// Union type for tool configuration
export const ToolConfigSchema = z.discriminatedUnion('__mode', [
  ExecToolConfigSchema.extend({ __mode: z.literal('exec') }),
  ShellToolConfigSchema.extend({ __mode: z.literal('shell') }),
  LegacyToolConfigSchema.extend({ __mode: z.literal('legacy') }),
]);

export type ExecToolConfig = z.infer<typeof ExecToolConfigSchema>;
export type ShellToolConfig = z.infer<typeof ShellToolConfigSchema>;
export type LegacyToolConfig = z.infer<typeof LegacyToolConfigSchema>;
export type ToolConfig = z.infer<typeof ToolConfigSchema>;
```

#### Task 1.2: Add Metadata Fields to ToolDefinition (30 min)

```typescript
// Add debugging metadata to internal ToolDefinition
export const ToolDefinitionSchema = z.object({
  name: z.string(),
  command: z.array(z.string()).min(1),
  parameters: z.array(ToolParameterSchema),

  // v1.7: Add metadata for debugging
  __meta: z.object({
    syntax: z.enum(['legacy', 'exec', 'shell']).optional(),
    original_template: z.string().optional(),
  }).optional(),
}).refine(/* existing validation rules */);
```

#### Task 1.3: Validation Function for Mutual Exclusivity (45 min)

```typescript
// Helper to detect tool config mode
export function detectToolConfigMode(rawConfig: unknown): 'exec' | 'shell' | 'legacy' | 'invalid' {
  const hasExec = 'exec' in (rawConfig as object);
  const hasShell = 'shell' in (rawConfig as object);
  const hasCommand = 'command' in (rawConfig as object) && Array.isArray((rawConfig as any).command);

  const count = [hasExec, hasShell, hasCommand].filter(Boolean).length;

  if (count === 0) return 'invalid';
  if (count > 1) return 'invalid'; // Mutually exclusive

  if (hasExec) return 'exec';
  if (hasShell) return 'shell';
  return 'legacy';
}
```

**Deliverables:**
- ‚úÖ `ExecToolConfigSchema`, `ShellToolConfigSchema` defined
- ‚úÖ `ToolConfig` union type created
- ‚úÖ `detectToolConfigMode()` helper function
- ‚úÖ Unit tests for schema validation

---

### Phase 2: ToolExpander Module (4-5 hours)

**Objective**: Implement syntax sugar ‚Üí internal representation transformation

**New File:** `src/tool-expander.ts`

**Tasks:**

#### Task 2.1: Placeholder Parser (1h)

```typescript
// src/tool-expander.ts

interface Placeholder {
  name: string;
  position: number; // Position in template (0-indexed)
  isRaw: boolean;   // true if ${param:raw}
  fullMatch: string; // e.g., "${param:raw}"
}

/**
 * Extract all ${param} and ${param:raw} placeholders from template
 */
export function extractPlaceholders(template: string): Placeholder[] {
  const regex = /\$\{(\w+)(:raw)?\}/g;
  const placeholders: Placeholder[] = [];
  let match;
  let position = 0;

  while ((match = regex.exec(template)) !== null) {
    placeholders.push({
      name: match[1],
      position: position++,
      isRaw: match[2] === ':raw',
      fullMatch: match[0],
    });
  }

  return placeholders;
}
```

#### Task 2.2: Exec Mode Expander (1h)

```typescript
/**
 * Expand exec: template to internal ToolDefinition
 */
export function expandExecMode(config: ExecToolConfig): ToolDefinition {
  // Step 1: Validate no shell metacharacters
  validateExecSafety(config.exec);

  // Step 2: Tokenize template using shell-like lexer
  const tokens = tokenizeExecTemplate(config.exec);

  // Step 3: Separate static parts from placeholders
  const { commandTokens, placeholders } = separateStaticAndDynamic(tokens);

  // Step 4: Infer parameters from placeholders
  const inferredParams = placeholders.map((ph, idx) => ({
    name: ph.name,
    type: 'string' as const,
    inject_as: 'argument' as const,
    position: idx,
  }));

  // Step 5: Handle stdin parameter
  if (config.stdin) {
    const stdinParam = inferredParams.find(p => p.name === config.stdin);
    if (stdinParam) {
      stdinParam.inject_as = 'stdin';
    } else {
      // stdin parameter not in template - add it
      inferredParams.push({
        name: config.stdin,
        type: 'string',
        inject_as: 'stdin',
        position: -1, // Special: not in template
      });
    }
  }

  // Step 6: Merge with explicit parameters
  const finalParams = mergeParameters(inferredParams, config.parameters);

  return {
    name: config.name,
    command: commandTokens,
    parameters: finalParams,
    __meta: {
      syntax: 'exec',
      original_template: config.exec,
    },
  };
}

/**
 * Validate exec: template doesn't contain shell metacharacters
 */
function validateExecSafety(template: string): void {
  const dangerousChars = ['|', '>', '<', '&', ';', '&&', '||', '`', '$(', '${'];
  for (const char of dangerousChars) {
    if (template.includes(char)) {
      throw new Error(
        `Shell metacharacter '${char}' not allowed in exec: mode. ` +
        `Use shell: mode if you need ${char}, or remove it for safe execution.`
      );
    }
  }
}

/**
 * Tokenize exec: template using shell-like lexer (like shlex.split)
 */
function tokenizeExecTemplate(template: string): string[] {
  // Use a shell lexer library (e.g., shell-quote for Node.js)
  // This properly handles quoted strings and escapes
  const { parse } = require('shell-quote');
  return parse(template);
}
```

#### Task 2.3: Shell Mode Expander (1.5h)

```typescript
/**
 * Expand shell: template to internal ToolDefinition with sh -c --
 */
export function expandShellMode(config: ShellToolConfig): ToolDefinition {
  // Step 1: Extract placeholders
  const placeholders = extractPlaceholders(config.shell);

  // Step 2: Validate :raw is not in exec mode (already validated by caller)

  // Step 3: Replace placeholders with positional parameters
  let script = config.shell;
  placeholders.forEach((ph, idx) => {
    const positional = ph.isRaw ? `$${idx + 1}` : `"$${idx + 1}"`;
    script = script.replace(ph.fullMatch, positional);
  });

  // Step 4: Build command array with sh -c --
  const command = ['sh', '-c', script, '--'];

  // Step 5: Infer parameters
  const inferredParams = placeholders.map((ph, idx) => ({
    name: ph.name,
    type: 'string' as const,
    inject_as: 'argument' as const,
    position: idx,
    __raw: ph.isRaw, // Internal metadata
  }));

  // Step 6: Handle stdin (similar to exec mode)
  if (config.stdin) {
    const stdinParam = inferredParams.find(p => p.name === config.stdin);
    if (stdinParam) {
      stdinParam.inject_as = 'stdin';
    } else {
      inferredParams.push({
        name: config.stdin,
        type: 'string',
        inject_as: 'stdin',
        position: -1,
      });
    }
  }

  // Step 7: Merge with explicit parameters
  const finalParams = mergeParameters(inferredParams, config.parameters);

  return {
    name: config.name,
    command,
    parameters: finalParams,
    __meta: {
      syntax: 'shell',
      original_template: config.shell,
    },
  };
}
```

#### Task 2.4: Parameter Merging Logic (1h)

```typescript
/**
 * Merge inferred parameters with explicit parameters block
 * Implements 3-step algorithm from spec Section 3.7.1
 */
function mergeParameters(
  inferred: InferredParameter[],
  explicit: ToolParameter[] | undefined
): ToolParameter[] {
  if (!explicit) return inferred as ToolParameter[];

  const merged = new Map<string, ToolParameter>();

  // Step 1: Add all inferred parameters
  for (const param of inferred) {
    merged.set(param.name, param as ToolParameter);
  }

  // Step 2: Merge explicit parameters
  for (const explicitParam of explicit) {
    const inferredParam = merged.get(explicitParam.name);

    if (!inferredParam) {
      // Error: Parameter not found in template
      throw new Error(
        `Parameter '${explicitParam.name}' not found in template. ` +
        `Available parameters: ${Array.from(merged.keys()).join(', ')}`
      );
    }

    // Step 3: Validate injection mode consistency
    if (explicitParam.inject_as && explicitParam.inject_as !== inferredParam.inject_as) {
      throw new Error(
        `Cannot override inject_as for parameter '${explicitParam.name}' ` +
        `(inferred: ${inferredParam.inject_as}, explicit: ${explicitParam.inject_as})`
      );
    }

    // Override metadata fields (description, default)
    merged.set(explicitParam.name, {
      ...inferredParam,
      description: explicitParam.description || inferredParam.description,
      // Add other overridable fields here
    });
  }

  return Array.from(merged.values());
}
```

**Deliverables:**
- ‚úÖ `extractPlaceholders()` function
- ‚úÖ `expandExecMode()` with safety validation
- ‚úÖ `expandShellMode()` with sh -c -- wrapping
- ‚úÖ `mergeParameters()` with 3-step algorithm
- ‚úÖ Unit tests for all expansion scenarios

---

### Phase 3: Config Loading Integration (2 hours)

**Objective**: Integrate ToolExpander into config loading pipeline

**Files to Modify:**
- `src/config.ts`

**Tasks:**

#### Task 3.1: Update loadAndValidateAgent (1h)

```typescript
// src/config.ts

import { ToolExpander } from './tool-expander.js';

export async function loadAndValidateAgent(
  agentPath: string
): Promise<{ config: AgentConfig; systemPrompt: string }> {
  // ... existing code ...

  // Load and parse config.yaml
  const rawConfig = yaml.parse(configContent);

  // NEW: Expand simplified tool syntax
  if (rawConfig.tools) {
    const expander = new ToolExpander();
    rawConfig.tools = rawConfig.tools.map((tool: unknown) => {
      const mode = detectToolConfigMode(tool);

      if (mode === 'exec' || mode === 'shell') {
        // Expand syntax sugar to internal representation
        return expander.expand(tool);
      } else if (mode === 'legacy') {
        // Keep as-is
        return tool;
      } else {
        throw new Error(`Invalid tool configuration: must have exec:, shell:, or command: field`);
      }
    });
  }

  // Validate with Zod (existing code)
  const config = AgentConfigSchema.parse(rawConfig);

  // ... rest of existing code ...
}
```

#### Task 3.2: Add Detailed Error Messages (1h)

```typescript
// Enhanced error handling for config loading

try {
  const expandedTool = expander.expand(tool);
} catch (error) {
  if (error instanceof ToolExpansionError) {
    // Provide helpful error with context
    throw new Error(
      `Failed to expand tool '${tool.name}':\n` +
      `  ${error.message}\n` +
      `  Template: ${tool.exec || tool.shell}\n` +
      `  Hint: ${error.hint}`
    );
  }
  throw error;
}
```

**Deliverables:**
- ‚úÖ Tool expansion integrated into `loadAndValidateAgent()`
- ‚úÖ Backward compatibility preserved (legacy tools unchanged)
- ‚úÖ Detailed error messages with hints
- ‚úÖ Integration tests for config loading

---

### Phase 4: CLI Transparency Tool (2 hours)

**Objective**: Implement `delta tool expand` command

**New File:** `src/commands/tool-expand.ts`
**Files to Modify:** `src/cli.ts` or `src/index.ts`

**Tasks:**

#### Task 4.1: Implement Tool Expand Command (1h)

```typescript
// src/commands/tool-expand.ts

import yaml from 'yaml';
import { ToolExpander } from '../tool-expander.js';

export async function toolExpandCommand(configPath: string): Promise<void> {
  // Read config file
  const rawConfig = yaml.parse(await fs.readFile(configPath, 'utf-8'));

  if (!rawConfig.tools) {
    console.error('No tools found in config');
    process.exit(1);
  }

  // Expand all tools
  const expander = new ToolExpander();
  const expandedTools = rawConfig.tools.map((tool: unknown) => {
    const mode = detectToolConfigMode(tool);

    if (mode === 'exec' || mode === 'shell') {
      return expander.expand(tool);
    }
    return tool; // Keep legacy as-is
  });

  // Output expanded config
  const expandedConfig = {
    ...rawConfig,
    tools: expandedTools,
  };

  console.log('# Expanded Configuration (v1.7 syntax sugar resolved)\n');
  console.log(yaml.stringify(expandedConfig, { indent: 2 }));
}
```

#### Task 4.2: Add CLI Integration (1h)

```typescript
// src/cli.ts

program
  .command('tool')
  .description('Tool configuration utilities')
  .command('expand <config-path>')
  .description('Expand v1.7 simplified syntax to full configuration')
  .action(async (configPath: string) => {
    await toolExpandCommand(configPath);
  });
```

**Deliverables:**
- ‚úÖ `delta tool expand` command working
- ‚úÖ YAML output with comments
- ‚úÖ Error handling for invalid configs
- ‚úÖ CLI tests

---

### Phase 5: Comprehensive Testing (3-4 hours)

**Objective**: Implement all 19 verification tests from spec Section 10

**New Files:**
- `tests/unit/tool-expander.test.ts`
- `tests/integration/v1.7-syntax.test.ts`
- `tests/security/injection-prevention.test.ts`

**Tasks:**

#### Task 5.1: Unit Tests (1h)

- ‚úÖ Placeholder extraction
- ‚úÖ Exec mode expansion (10 test cases)
- ‚úÖ Shell mode expansion (10 test cases)
- ‚úÖ Parameter merging algorithm (8 test cases)
- ‚úÖ Validation errors (mutual exclusivity, metacharacters, :raw scope)

#### Task 5.2: Security Tests (1h)

Implement all tests from spec Section 10:
- ‚úÖ Test Suite 1: Command injection prevention (exec:)
- ‚úÖ Test Suite 2: Command injection prevention (shell:)
- ‚úÖ Test Suite 3: :raw modifier behavior

#### Task 5.3: Integration Tests (1h)

- ‚úÖ Test Suite 4: Tokenization and whitespace
- ‚úÖ Test Suite 5: stdin handling
- ‚úÖ Test Suite 6: Multi-line scripts
- ‚úÖ Test Suite 7: Parameter merging

#### Task 5.4: End-to-End Tests (1h)

- ‚úÖ Create example agent with v1.7 syntax
- ‚úÖ Test full workflow: load ‚Üí expand ‚Üí execute
- ‚úÖ Verify backward compatibility with existing agents

**Deliverables:**
- ‚úÖ 19/19 verification tests passing
- ‚úÖ 100% code coverage for ToolExpander
- ‚úÖ Security properties validated (no injection)
- ‚úÖ CI/CD pipeline integration

---

### Phase 6: Documentation & ADR (2 hours)

**Objective**: Complete documentation and architecture decision record

**Tasks:**

#### Task 6.1: Create ADR-005 (1h)

**File:** `docs/decisions/005-tool-syntax-simplification.md`

```markdown
# ADR-005: Tool Configuration Syntax Simplification

**Date**: 2025-10-11
**Status**: Active
**Related**: ADR-001 (Stateless Core)

## Context
[Copy from implementation plan Section 1]

## Decision
[Copy from spec Section 2]

## Consequences
**Benefits:**
- 60% reduction in config verbosity for common cases
- Maintained security through explicit contracts
- 100% backward compatible
- Transparent via `delta tool expand`

**Costs:**
- Additional config parser complexity
- Need to maintain two formats
- Learning curve for new syntax

**Mitigation:**
- Comprehensive test suite (19 tests)
- `delta tool expand` for transparency
- Migration examples in docs
```

#### Task 6.2: Update User Documentation (1h)

**Files to Update:**
- `docs/guides/agent-development.md` - Add v1.7 syntax examples
- `docs/api/config.md` - Document exec: and shell: fields
- `README.md` - Add quick example of simplified syntax

**Example Section:**

```markdown
### Tool Configuration (v1.7 Simplified Syntax)

**Old way (v1.0-v1.6):**
```yaml
tools:
  - name: count_lines
    command: [sh, -c, "cat \"$1\" | wc -l", --]
    parameters:
      - name: file
        type: string
        inject_as: argument
        position: 0
```

**New way (v1.7):**
```yaml
tools:
  - name: count_lines
    shell: "cat ${file} | wc -l"
```

‚ú® **60% less code, same functionality!**
```

**Deliverables:**
- ‚úÖ ADR-005 published
- ‚úÖ User guides updated with examples
- ‚úÖ CLAUDE.md updated with v1.7 reference
- ‚úÖ Migration guide created

---

## 4. Security Verification Strategy

### 4.1 Threat Model

**Threats to Mitigate:**
1. **Command Injection** (Critical): Malicious LLM output executing arbitrary commands
2. **Path Traversal** (High): Parameters containing `../` or absolute paths
3. **Resource Exhaustion** (Medium): Fork bombs via unquoted :raw
4. **Configuration Bypass** (Medium): Circumventing validation rules

### 4.2 Security Controls

**Control 1: exec: Mode - No Shell Involvement**
- **Implementation**: Direct `execvp()` call, no shell
- **Verification**: Test Suite 1 (3 tests)
- **Mitigation**: Reject shell metacharacters at config load

**Control 2: shell: Mode - Argv-based Parameterization**
- **Implementation**: `sh -c "script" -- "$1" "$2"`
- **Verification**: Test Suite 2 (4 tests), Section 4.2.1 proof
- **Mitigation**: Automatic quoting of positional parameters

**Control 3: :raw Scope Restriction**
- **Implementation**: Only allowed in shell: mode, explicit marker
- **Verification**: Test Suite 3.2 (rejection in exec:)
- **Mitigation**: Runtime warning in development mode (future)

### 4.3 Security Testing Checklist

Before release:
- [ ] All 19 verification tests pass
- [ ] Manual penetration testing with malicious inputs
- [ ] Code review by security-focused developer
- [ ] Fuzz testing with random inputs (optional but recommended)

---

## 5. Risk Assessment and Mitigation

### High Risk

**Risk 1: Incorrect sh -c Implementation**
- **Impact**: Critical - Command injection vulnerability
- **Probability**: Medium (complex shell semantics)
- **Mitigation**:
  - Implement Test Suite 2 first (before any code)
  - Use `execvp()` directly, not `system()`
  - Code review focused on Section 4.2.1 compliance
- **Contingency**: Feature flag to disable v1.7 syntax

**Risk 2: Tokenization Edge Cases**
- **Impact**: High - Incorrect command execution
- **Probability**: Medium (many edge cases in shell parsing)
- **Mitigation**:
  - Use well-tested library (shell-quote, shlex)
  - Test Suite 4 covers whitespace and quoting
  - Fuzz testing with random inputs
- **Contingency**: Fallback to error on ambiguous syntax

### Medium Risk

**Risk 3: Backward Compatibility Break**
- **Impact**: Medium - Existing agents fail
- **Probability**: Low (design is additive)
- **Mitigation**:
  - Test all example agents with new code
  - Regression test suite in CI/CD
- **Contingency**: Quick patch release

**Risk 4: Performance Degradation**
- **Impact**: Low - Config loading slower
- **Probability**: Low (parsing happens once)
- **Mitigation**:
  - Benchmark config loading before/after
  - Optimize hot paths if needed
- **Contingency**: Accept minor slowdown (<100ms)

### Low Risk

**Risk 5: Documentation Gaps**
- **Impact**: Low - User confusion
- **Probability**: Medium (complex feature)
- **Mitigation**:
  - Comprehensive examples in docs
  - `delta tool expand` for self-documentation
- **Contingency**: Iterative doc improvements

---

## 6. Success Criteria

### Must-Have (P0) - Blocking Release

- ‚úÖ All 19 verification tests pass (Section 10 of spec)
- ‚úÖ 100% backward compatibility (all existing tests pass)
- ‚úÖ `delta tool expand` command working
- ‚úÖ Security validations enforced:
  - exec: mode rejects shell metacharacters
  - :raw only allowed in shell: mode
  - Mutual exclusivity validated
- ‚úÖ ADR-005 published
- ‚úÖ Zero known security vulnerabilities

### Should-Have (P1) - Post-Release if Needed

- ‚úÖ 2+ example agents using v1.7 syntax
- ‚úÖ Migration guide (legacy ‚Üí v1.7) with 10+ examples
- ‚úÖ Test coverage >90% for ToolExpander module
- ‚úÖ Performance benchmark (config load <100ms overhead)

### Nice-to-Have (P2) - Future Enhancements

- ‚≠ê `delta tool lint` command (static analysis)
- ‚≠ê Development mode runtime warnings for :raw
- ‚≠ê VSCode extension for syntax highlighting
- ‚≠ê Auto-migration tool (legacy ‚Üí v1.7)

---

## 7. Timeline and Milestones

### Week 1: Core Implementation (Days 1-5)

**Day 1-2: Foundation**
- [ ] Phase 1: Type system extension (3h)
- [ ] Phase 2 (partial): Placeholder parsing (1h)

**Day 3-4: Expanders**
- [ ] Phase 2 (complete): Exec/shell expanders (4h)
- [ ] Integration tests for expanders (1h)

**Day 5: Integration**
- [ ] Phase 3: Config loading integration (2h)
- [ ] Backward compatibility testing (1h)

**Milestone 1**: Core expansion working, tests passing ‚úÖ

---

### Week 2: Tooling & Testing (Days 6-10)

**Day 6-7: CLI Tool**
- [ ] Phase 4: `delta tool expand` command (2h)
- [ ] CLI tests and documentation (1h)

**Day 8-9: Security Testing**
- [ ] Phase 5: Implement all 19 verification tests (3h)
- [ ] Manual penetration testing (1h)
- [ ] Code review session (2h)

**Day 10: Documentation**
- [ ] Phase 6: ADR-005 and user docs (2h)
- [ ] Final review and polish (1h)

**Milestone 2**: Feature complete, ready for release ‚úÖ

---

### Week 3: Polish & Release (Days 11-15)

**Day 11-12: Examples & Migration**
- [ ] Update 2 example agents to v1.7 syntax
- [ ] Create migration guide

**Day 13: Release Prep**
- [ ] Update CHANGELOG.md
- [ ] Update version numbers
- [ ] Create GitHub release notes

**Day 14: Beta Release**
- [ ] Deploy to npm with `@beta` tag
- [ ] Announce in community channels
- [ ] Monitor for issues

**Day 15: Final Release**
- [ ] Address beta feedback (if any)
- [ ] Publish to npm stable
- [ ] Update documentation site

**Milestone 3**: v1.7 released üéâ

---

## 8. Testing Strategy

### 8.1 Unit Tests (tests/unit/tool-expander.test.ts)

**Coverage Target**: >95%

```typescript
describe('ToolExpander', () => {
  describe('extractPlaceholders', () => {
    it('should extract simple placeholders', () => {
      const result = extractPlaceholders('echo ${msg}');
      expect(result).toEqual([
        { name: 'msg', position: 0, isRaw: false, fullMatch: '${msg}' }
      ]);
    });

    it('should extract :raw modifier', () => {
      const result = extractPlaceholders('docker run ${flags:raw} ${image}');
      expect(result).toHaveLength(2);
      expect(result[0].isRaw).toBe(true);
      expect(result[1].isRaw).toBe(false);
    });

    // ... 15 more test cases
  });

  describe('expandExecMode', () => {
    it('should reject pipe operator', () => {
      expect(() => expandExecMode({ exec: 'cat ${file} | wc' }))
        .toThrow('Shell metacharacter');
    });

    // ... 20 more test cases
  });

  describe('expandShellMode', () => {
    it('should generate sh -c with quoted params', () => {
      const result = expandShellMode({ shell: 'grep ${pattern} ${file}' });
      expect(result.command).toEqual([
        'sh', '-c', 'grep "$1" "$2"', '--'
      ]);
    });

    // ... 20 more test cases
  });
});
```

### 8.2 Security Tests (tests/security/injection-prevention.test.ts)

**Critical Test Cases:**

```typescript
describe('Command Injection Prevention', () => {
  it('should prevent semicolon injection in shell mode', async () => {
    // Create temp file to verify non-deletion
    const marker = '/tmp/delta_test_injection';
    await fs.writeFile(marker, 'test');

    const tool = expandShellMode({ shell: 'echo ${input}' });
    await executeTool(context, tool, {
      input: '; rm -rf ' + marker + '; echo done'
    });

    // Verify file still exists (no command injection)
    expect(await fs.access(marker)).resolves.toBeUndefined();
    await fs.unlink(marker);
  });

  // ... all 19 tests from spec Section 10
});
```

### 8.3 Integration Tests (tests/integration/v1.7-syntax.test.ts)

Test end-to-end workflow:
- Load config with v1.7 syntax
- Expand to internal representation
- Execute tools with LLM-provided parameters
- Verify correct behavior

### 8.4 Regression Tests

Ensure all existing tests still pass:
```bash
npm run test:unit     # All existing unit tests
npm run test:integration  # All existing integration tests
npm run test:e2e      # All existing e2e tests
```

---

## 9. Documentation Checklist

### Code Documentation

- [ ] JSDoc comments on all public functions
- [ ] Type annotations on all parameters
- [ ] Examples in TSDoc for complex functions

### User Documentation

- [ ] `docs/guides/tool-configuration-v1.7.md` - Comprehensive guide
- [ ] `docs/api/config.md` - Updated schema reference
- [ ] `docs/guides/migration-v1.6-to-v1.7.md` - Migration guide
- [ ] `README.md` - Quick example in main README

### Internal Documentation

- [ ] ADR-005 in `docs/decisions/`
- [ ] Implementation plan (this document)
- [ ] CHANGELOG.md entry for v1.7

### CLAUDE.md Updates

- [ ] Add v1.7 to "Version Context" section
- [ ] Update "Adding New Features" with tool syntax examples
- [ ] Link to v1.7 specification and implementation plan

---

## 10. Rollback Plan

### Feature Flag

Add environment variable to disable v1.7 syntax:

```typescript
// src/config.ts

const ENABLE_V17_SYNTAX = process.env.DELTA_ENABLE_V17_SYNTAX !== 'false';

export async function loadAndValidateAgent(agentPath: string) {
  // ...

  if (ENABLE_V17_SYNTAX && (mode === 'exec' || mode === 'shell')) {
    return expander.expand(tool);
  } else if (mode === 'exec' || mode === 'shell') {
    throw new Error('v1.7 syntax disabled. Set DELTA_ENABLE_V17_SYNTAX=true to enable.');
  }

  // ... legacy handling
}
```

### Rollback Procedure

If critical bug found post-release:

1. **Immediate**: Set `DELTA_ENABLE_V17_SYNTAX=false` in docs
2. **Within 24h**: Release patch version (v1.7.1) with bug fix
3. **If unfixable**: Revert to v1.6.x and pull v1.7.0 from npm

### Known Limitations (Acceptable for v1.7)

- Multi-character escaped sequences in static strings not supported (use full syntax)
- Maximum 9 positional parameters in shell: mode (POSIX limit)
- stdin: parameter must be explicitly declared (not auto-inferred from tools like `tee`)

---

## Appendix A: Development Commands

```bash
# Setup
npm install
npm run build

# Development workflow
npm run dev                  # Watch mode
npm run test:unit -- --watch  # TDD mode

# Pre-commit checks
npm run lint
npm run type-check
npm test

# Security testing
npm run test:security

# Release preparation
npm run build
npm run test
npm version minor  # 1.6.0 -> 1.7.0
git push --tags
npm publish
```

---

## Appendix B: Resources

**Specification:**
- [v1.7-tool-simplification.md](./v1.7-tool-simplification.md) - Full spec

**External References:**
- POSIX Shell Specification: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html
- shell-quote (Node.js): https://github.com/substack/node-shell-quote
- shlex (Python): https://docs.python.org/3/library/shlex.html

**Related ADRs:**
- ADR-001: Stateless Core Architecture
- ADR-002: Journal Format - JSONL
- ADR-004: POC-First Architecture Validation

---

**End of Implementation Plan**

**Next Steps**: Await approval, then begin Phase 1 implementation.
