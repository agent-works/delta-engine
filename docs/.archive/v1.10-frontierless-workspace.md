# Delta Engine Architecture Specification v1.10: Frontierless Workspace and Robust Orchestration

**Version**: 1.10.0
**Date**: October 14, 2025
**Status**: Final Specification
**Author**: Delta Engine Architecture Team

---

## 1. Executive Summary

Delta Engine v1.10 introduces a fundamental architectural evolution to support complex, concurrent multi-agent workflows such as "Plan-Execute" or "Map-Reduce" patterns. These patterns require multiple independent execution flows to operate within the same shared data workspace (CWD) for "Zero-Copy Orchestration."

This specification resolves the core conflict between shared workspaces and v1.x's reliance on a single global pointer (`.delta/LATEST`) to track the "latest" state, which fails under concurrent execution.

v1.10 introduces the **"Frontierless Workspace"** model. We remove all shared, mutable pointers within the workspace, fundamentally eliminating the possibility of state contention. This shifts the responsibility of tracking specific execution flows from the engine to the caller (orchestrator).

Key changes include control plane simplification, enhanced CLI behavior enforcing explicit run identification, and strict adherence to Unix I/O principles for robust automation via structured output contracts (`RunResult` v2.0).

## 2. Problem Analysis and Rationale

Delta Engine's core mission is to enable complex intelligence through composition of simple agents. Advanced orchestration patterns require agents to collaborate within the same CWD.

### 2.1 The Core Conflict

In v1.x, the `.delta/LATEST` file acts as a global pointer to the most recent `run_id`. This design assumes a "single active frontier"—at any moment, only one relevant execution history exists.

Concurrent workflows fundamentally break this assumption. If multiple agents (or multiple instances of the same agent) run concurrently in the same CWD, they compete to update `LATEST`. This causes race conditions, unpredictable state tracking, and failure of mechanisms that depend on this pointer (like `delta continue`).

### 2.2 Fundamental Principle

Any attempt to track "latest" state using a shared, mutable pointer in a concurrent environment is fundamentally flawed. Proposals like "Execution Streams" (e.g., `.delta/streams/planner`) merely localize contention; if multiple `Planner` instances run concurrently, the problem remains unsolved.

To achieve true concurrency support and architectural robustness, we must eliminate shared mutable state from the control plane.

## 3. Architecture Solution

v1.10 adopts the "Frontierless Workspace" model.

### 3.1 Model Definition

A workspace (CWD) is defined solely as a container for data artifacts (data plane) and the execution histories that produced them (control plane). The workspace itself no longer tracks a global "execution focus" or "default frontier."

### 3.2 Control Plane: Flat Structure

We simplify the `.delta/` directory structure to reflect this model.

**v1.x Structure (Deprecated):**

```
W001/
└── .delta/
    ├── LATEST       # [Problem] Shared mutable pointer
    ├── {run_id_A}/
    │   ├── journal.jsonl
    │   └── metadata.json
    └── {run_id_B}/
```

**v1.10 Structure (Frontierless):**

```
W001/
└── .delta/
    ├── {run_id_A}/  # [Unchanged] Flat structure preserved
    │   ├── journal.jsonl
    │   └── metadata.json
    ├── {run_id_B}/
    └── LATEST       # [Removed] Eliminates contention source
```

By removing `LATEST` and maintaining a flat structure, we physically eliminate the source of contention, enabling unlimited concurrency within the workspace.

**Design Rationale**: We preserve the flat structure (no `runs/` subdirectory) to minimize breaking changes and implementation complexity. The directory naming convention (`run_id` format) provides sufficient semantic clarity.

### 3.3 New Contract: Orchestrator Responsibility

This architectural shift requires a new contract between the engine and callers (orchestrators, whether parent agents, scripts, or CI/CD systems).

**Contract**: The responsibility for tracking specific `run_id` belongs to the orchestrator, not the engine.

In automation scenarios where robustness is critical, we follow the "Explicit over Implicit" principle (ADR-005). The engine must enforce explicit identification of target runs.

1. **Starting a Run**: Orchestrators must invoke `delta run` (recommended with `--format json`) and reliably capture the returned `run_id`.
2. **Continuing a Run**: Orchestrators must use the captured ID to explicitly continue specific execution flows via `delta continue --run-id <id>`.

### 3.4 Client-Generated Run ID

To ensure orchestrators can track `run_id` even in catastrophic failure scenarios (e.g., `kill -9`), we introduce client-generated run IDs.

**New Parameter**: `delta run --run-id <ID>`

**Behavior**:
- When provided, the engine uses the specified ID to initialize the run.
- If not provided, the engine auto-generates an ID (suitable for interactive scenarios).
- **Uniqueness Guarantee**: If a run with the same ID already exists in the workspace, the engine must error and exit immediately.

**Robustness Advantage**: Even if the engine crashes fatally, the orchestrator retains the `run_id` for subsequent recovery operations. This fundamentally solves the tracking problem.

**Recommendation**: In all automated orchestration scenarios, mandate use of client-generated Run IDs (recommend UUID v4).

**Example**:
```bash
# Robust orchestration pattern
RUN_ID=$(uuidgen)
delta run --run-id "$RUN_ID" -m "Task description" --format json

# If process is killed, RUN_ID is still available
delta continue --run-id "$RUN_ID"
```

### 3.5 The Janitor Mechanism

Client-generated IDs solve tracking, but we must also address recovery safety. When a process is terminated via `kill -9`, its state record remains in `RUNNING` status. We must ensure the original process has died before safely resuming execution, preventing two processes from simultaneously manipulating the same run history (data corruption).

We adopt a passive "Janitor" mechanism to achieve safe state cleanup.

#### 3.5.1 Implementation Requirements

1. **PID Recording**: When `delta run` starts, it must immediately record its process ID (PID) in `.delta/{run_id}/metadata.json`.

2. **Janitor Execution Point**: Janitor logic is embedded in the `delta continue` command.

3. **Safety Check and Transition**: When attempting to continue a run (whether explicit or otherwise), if its status is `RUNNING`:
   - Janitor checks if the recorded PID is still alive (using OS standard calls, e.g., `kill -0` on Unix-like systems).
   - **If PID does not exist**: Janitor automatically updates status from `RUNNING` to `INTERRUPTED` and allows continuation.
   - **If PID still exists**: Engine must refuse continuation and error, indicating the run is still active. This guarantees at most one active process per `run_id` at any moment.

#### 3.5.2 Enhanced PID Validation

To prevent false positives from PID reuse (OS reassigns PID to a different process), Janitor must perform multi-factor verification:

1. **Process Liveness Check**: Use `kill -0` (Unix) or equivalent API (Windows)
2. **Process Name Verification**: Check if process name contains `node` or `delta`
3. **Start Time Verification** (Optional): Compare recorded start time with actual process start time

**Metadata Extension**:
```json
{
  "run_id": "20251014_0430_aaaa",
  "pid": 12345,
  "hostname": "host-a",
  "start_time": "2025-10-14T10:30:00Z",
  "process_name": "node"
}
```

#### 3.5.3 Cross-Host Scenario Safety

In shared file system environments (NFS, CIFS), PID checks cannot verify processes on different hosts. We must detect and handle this scenario:

**Detection**: Record hostname during run initialization.

**Behavior**: If `hostname` in metadata doesn't match current hostname, engine must refuse automatic recovery and provide clear error:

```
Error: Run 20251014_0430_aaaa was started on host 'host-a'.
Cannot verify process status from host 'host-b'.

If you're certain the original process is dead, use:
  delta continue --run-id 20251014_0430_aaaa --force
```

**Safety Escape Hatch**: `--force` flag allows user to explicitly confirm original process has terminated.

## 4. Interface Design: Robust Output and I/O Philosophy

To support robust orchestration, v1.10 strictly enforces Unix I/O conventions, ensuring clear separation between process information and data output.

### 4.1 I/O Separation (stdout vs stderr)

- **`stderr` (Process)**: All real-time process information, engine logs, and agent's "Think-Act-Observe" stream. This guarantees observability while keeping `stdout` pure. By convention, `stderr` is always active; callers can redirect as needed (e.g., `2> /dev/null`).

- **`stdout` (Result)**: Reserved exclusively for final execution results. This is the data contract of execution.

**Note**: Interactive mode flag (`-i`) controls *input* behavior (sync/async `ask_human`); it does not affect output format. Output is controlled by the `--format` flag.

### 4.2 Output Modes (`--format`)

We provide three output formats balancing clarity, composability, and automation needs.

#### 4.2.1 Default/Interactive Mode (`--format text`)

Optimized for human readability and clarity. Prioritizes clarity over purity.

- **`stderr`**: Real-time execution log stream.
- **`stdout`**: At execution end, prints a clear, structured human-readable summary including status and metadata.

**`stdout` Example (COMPLETED)**:
```text
--- Run Summary ---
Run ID:     20251014_0430_aaaa
Status:     COMPLETED
Duration:   2m 30s
-------------------
Result:
{
  "summary": "Analysis complete.",
  "report_file": "W001/report.pdf",
  "confidence_score": 0.95
}
-------------------
```

**`stdout` Example (FAILED)**:
```text
--- Run Summary ---
Run ID:     20251014_0430_aaaa
Status:     FAILED
Duration:   45s
-------------------
Error: Tool 'analyze_data' execution failed.
Details: File not found: data.csv
-------------------
```

#### 4.2.2 Automation Mode (`--format json`)

Optimized for machine readability and robust parsing by orchestrators.

- **`stderr`**: Real-time execution log stream.
- **`stdout`**: A single structured JSON object (`RunResult` v2.0 Schema, see Section 5) printed at execution end.

**Usage Example**:
```bash
# Capture stdout (JSON), redirect stderr (logs)
OUTPUT=$(delta run -m "Task" --format json 2> run.log)
RUN_ID=$(echo "$OUTPUT" | jq -r '.run_id')
RESULT_DATA=$(echo "$OUTPUT" | jq '.result')
```

#### 4.2.3 Raw/Composable Mode (`--format raw`)

Optimized for Unix composability (pipes). Provides pure data output.

- **Contract**: When using this mode, callers **must** rely on exit codes to determine status.
- **`stderr`**: Real-time execution log stream.
- **`stdout` Behavior**:
  1. **`COMPLETED` (Exit 0)**: Contains only pure `result` data (strings output directly, objects output as compact JSON).
  2. **Other statuses (Exit != 0)**: `stdout` is empty. Error information only in `stderr`.

**Usage Example (Unix Composition)**:
```bash
# Pipe pure object result to jq
$ delta run -m "Analyze data" --format raw | jq '.report_file'

# Pipe string result to file
$ delta run -m "Generate summary" --format raw > summary.txt
```

### 4.3 Standardized Exit Codes

Exit codes provide standardized signals for script control flow.

| Exit Code | Status | Meaning |
|-----------|--------|---------|
| **0** | COMPLETED | Success. |
| **1** | FAILED | General failure (agent logic or engine error). |
| **101** | WAITING_FOR_INPUT | Interaction required (v1.x convention). |
| **126** | FAILED (Config/Exec) | Cannot execute (config error, permission issue). |
| **130** | INTERRUPTED | Interrupted by signal (e.g., Ctrl+C). |

## 5. Execution Contract: RunResult v2.0 Schema

The `RunResult` Schema defines the structured output for `--format json`. It includes execution status, key `result` data (captured from final tool invocation, e.g., `finish`), and detailed metrics.

```json
{
  "schema_version": "2.0",
  "run_id": "20251014_0430_aaaa",
  "status": "COMPLETED | FAILED | WAITING_FOR_INPUT | INTERRUPTED",

  // --- Core Output (Conditional Fields) ---
  // Only one of the following three fields will be present, depending on 'status'.

  // [Key] Agent's final output. Supports String or Object.
  // Only present when status == COMPLETED.
  "result": null,
  /* Example (Object):
  "result": {
    "summary": "Analysis complete.",
    "report_file": "W001/report.pdf",
    "confidence_score": 0.95
  }
  */

  // Error details. Only present when status == FAILED or INTERRUPTED.
  "error": {
    "type": "EngineError | ToolExecutionError | Interrupted | ...",
    "message": "Tool 'analyze_data' execution failed.",
    "details": "..."
  },

  // Interaction details. Only present when status == WAITING_FOR_INPUT.
  "interaction": {
    "prompt": "Please confirm the plan.",
    "input_type": "text | password | confirmation",
    "sensitive": false
  },

  // --- Metrics and Usage ---
  "metrics": {
    "iterations": 15,
    "duration_ms": 150000,
    "start_time": "2025-10-14T10:30:00Z",
    "end_time": "2025-10-14T10:32:30Z",
    "usage": {
      "total_cost_usd": 0.27176,
      "input_tokens": 120000,
      "output_tokens": 5000,
      "model_usage": {
        // Per-model detailed statistics
        "gpt-4o": {
          "calls": 15,
          "input_tokens": 120000,
          "output_tokens": 5000,
          "cost_usd": 0.27176
        }
      }
    }
  },

  // --- Metadata ---
  "metadata": {
    "agent_name": "MyAgent",
    "workspace_path": "/path/to/W001"
  }
}
```

## 6. CLI Behavior: Explicit-Only Resumption

v1.10 adopts a strict "explicit-only" resumption policy, aligning with the Frontierless Workspace philosophy and the "Explicit over Implicit" principle (ADR-005).

### 6.1 `delta continue --run-id` (Required)

The `delta continue` command **requires** the `--run-id` parameter in all scenarios.

**Syntax**:
```bash
delta continue --run-id <run_id> [OPTIONS]
```

**Behavior**:
- If `--run-id` is not provided, the engine immediately errors with a clear message.
- When `--run-id` is provided:
  1. Verify the run exists in the workspace.
  2. Trigger Janitor mechanism (if status is `RUNNING`, perform PID check and safe state transition).
  3. Resume the specified run.

**Error Example**:
```bash
$ delta continue -w W001
Error: --run-id is required.

To resume a run, you must explicitly specify its ID:
  delta continue --run-id <run_id>

To list resumable runs:
  delta list-runs -w W001 --resumable
```

### 6.2 Auxiliary Tool: `delta list-runs`

To support efficient run identification, we introduce a new auxiliary command.

**Syntax**:
```bash
delta list-runs [OPTIONS]
```

**Options**:
- `-w, --work-dir <path>`: Workspace path (default: current directory)
- `--resumable`: Filter to only resumable runs (INTERRUPTED, WAITING_FOR_INPUT, FAILED, COMPLETED)
- `--status <status>`: Filter by specific status
- `--first`: Return only the most recent run ID (for scripting)
- `--format <text|json>`: Output format (default: text)

**Output Example (text)**:
```bash
$ delta list-runs -w W001 --resumable
20251014_0430_aaaa  INTERRUPTED       "Analyze data"     2m ago
20251014_0435_bbbb  WAITING_FOR_INPUT "Process report"   1m ago
20251014_0440_cccc  FAILED            "Generate chart"   30s ago
```

**Output Example (json)**:
```bash
$ delta list-runs -w W001 --resumable --format json
[
  {
    "run_id": "20251014_0430_aaaa",
    "status": "INTERRUPTED",
    "task_summary": "Analyze data",
    "last_updated": "2025-10-14T10:30:00Z"
  },
  ...
]
```

**Quick Resume Pattern**:
```bash
# Resume the most recent resumable run
RUN_ID=$(delta list-runs -w W001 --resumable --first)
delta continue --run-id "$RUN_ID"

# One-liner
delta continue --run-id $(delta list-runs --resumable --first)
```

### 6.3 User Convenience Layer (Documentation Examples)

We encourage users to build custom convenience wrappers tailored to their workflows. The documentation provides reference implementations.

**Example: Interactive Resume Helper** (`~/.bashrc` or `~/.zshrc`):
```bash
# Smart resume: auto-select if single resumable run, otherwise show menu
delta-resume() {
  local workspace=${1:-.}
  local runs=$(delta list-runs -w "$workspace" --resumable --format json)
  local count=$(echo "$runs" | jq 'length')

  if [ "$count" -eq 0 ]; then
    echo "No resumable runs found in $workspace"
    return 1
  elif [ "$count" -eq 1 ]; then
    local run_id=$(echo "$runs" | jq -r '.[0].run_id')
    echo "Resuming run: $run_id"
    delta continue --run-id "$run_id" -w "$workspace"
  else
    echo "Multiple resumable runs found:"
    echo "$runs" | jq -r '.[] | "\(.run_id)  \(.status)  \(.task_summary)"'
    echo -n "Enter run_id to resume: "
    read run_id
    delta continue --run-id "$run_id" -w "$workspace"
  fi
}
```

**Usage**:
```bash
$ delta-resume          # Resume in current workspace
$ delta-resume W001     # Resume in W001
```

**Design Philosophy**: By providing convenience as external scripts rather than engine internals, we:
- Keep the engine simple and correct (Unix philosophy)
- Empower users to customize behavior for their workflows
- Maintain architectural purity ("Explicit over Implicit")
- Enable composition with other Unix tools

## 7. Implementation Requirements

To guarantee the reliability of output contracts, engine implementation must adhere to the **"Persist-First, Print-Last"** principle.

### 7.1 Persist-First, Print-Last

The engine must ensure final state (including status, result, and metrics) is successfully persisted to `.delta/{run_id}/metadata.json` before exiting. Final output generation logic (in global exit handler) must read this persisted state to generate `stdout` output. This maximizes the guarantee that even in the event of unexpected crashes during engine shutdown, callers can receive execution results.

### 7.2 Run ID and PID Initialization

The engine must perform the following initialization sequence before executing any operations that may produce side effects:

1. **Uniqueness Check**: If client provides `--run-id`, verify it doesn't conflict with existing runs in the workspace. Exit immediately on conflict.
2. **Metadata Initialization**: Create `.delta/{run_id}/metadata.json` with initial state:
   - `run_id`: Client-provided or auto-generated
   - `pid`: Current process ID
   - `hostname`: Current hostname
   - `start_time`: Current timestamp
   - `process_name`: Process name (e.g., "node")
   - `status`: "RUNNING"

### 7.3 Janitor Implementation Details

The Janitor mechanism must be implemented in `delta continue` command with the following logic:

**Algorithm**:
```typescript
async function janitorCheck(runId: string, metadata: RunMetadata): Promise<void> {
  if (metadata.status !== 'RUNNING') {
    return; // No cleanup needed
  }

  // Step 1: Cross-host detection
  if (metadata.hostname !== os.hostname()) {
    throw new Error(
      `Run ${runId} was started on host '${metadata.hostname}'. ` +
      `Cannot verify process status from host '${os.hostname()}'. ` +
      `If you're sure the original process is dead, use --force.`
    );
  }

  // Step 2: PID liveness check
  const isAlive = await isProcessAlive(metadata.pid);

  if (isAlive) {
    // Step 3: Process name verification (prevent PID reuse false positive)
    const processName = await getProcessName(metadata.pid);
    if (processName.includes('node') || processName.includes('delta')) {
      throw new Error(
        `Run ${runId} is still active (PID ${metadata.pid}). ` +
        `Cannot continue while original process is running.`
      );
    }
  }

  // Step 4: Safe state transition
  metadata.status = 'INTERRUPTED';
  await persistMetadata(runId, metadata);
  console.error(`[Janitor] Cleaned up orphaned run ${runId} (dead process)`);
}
```

**Helper Functions**:
```typescript
// Unix implementation
async function isProcessAlive(pid: number): Promise<boolean> {
  try {
    process.kill(pid, 0); // Signal 0 checks existence without killing
    return true;
  } catch (err) {
    return false;
  }
}

async function getProcessName(pid: number): Promise<string> {
  // Read from /proc/{pid}/comm on Linux
  // Use ps command on macOS: ps -p {pid} -o comm=
  // ...
}
```

## 8. Testing Strategy

v1.10 introduces mechanisms requiring dedicated test coverage.

### 8.1 New Test Scenarios

**Unit Tests** (`tests/unit/v1.10/`):
- Client-generated Run ID uniqueness validation
- Janitor PID check logic (including process name verification)
- Output format generation (text/json/raw)
- `delta list-runs` filtering and formatting

**Integration Tests** (`tests/integration/v1.10/`):
- Client-generated ID end-to-end flow
- Orphan run recovery flow (SIGKILL + continue)
- Cross-host scenario simulation (hostname mismatch)
- Multi-agent concurrent execution (2+ agents in same workspace)

**E2E Tests** (`tests/e2e/v1.10/`):
- Complete fault recovery user journey (run + kill + list + continue)
- Concurrent orchestration pattern (Plan-Execute workflow)
- Output format validation in real scenarios

**Example Test Case**:
```typescript
describe('Janitor Mechanism', () => {
  it('should clean up dead RUNNING process', async () => {
    const runId = uuidv4();

    // Start run and record PID
    const child = spawn('delta', ['run', '--run-id', runId, '-m', 'sleep 30']);
    await waitForRunning(runId);

    // Force kill process
    child.kill('SIGKILL');
    await delay(100);

    // Attempt recovery
    const result = await runDelta(['continue', '--run-id', runId]);
    expect(result.status).toBe('INTERRUPTED'); // Auto-cleanup
  });

  it('should reject continue if process still alive', async () => {
    const runId = uuidv4();
    spawn('delta', ['run', '--run-id', runId, '-m', 'sleep 30']);
    await waitForRunning(runId);

    // Original process still running
    await expect(
      runDelta(['continue', '--run-id', runId])
    ).rejects.toThrow('Run is still active');
  });
});
```

### 8.2 Coverage Targets

- **New Code**: ≥ 90% coverage
- **Core Modules** (engine, journal): ≥ 95% coverage
- **Overall Project**: ≥ 70% coverage

## 9. Breaking Changes and Impact

v1.10 introduces significant breaking changes compared to the v1.x series:

### 9.1 Removed Components

1. **`.delta/LATEST` file**: Eliminated from workspace structure.
2. **Implicit `delta continue`**: No longer supports invocation without `--run-id`.

### 9.2 Impact Assessment

**External Tools**: Any scripts or tools relying on `.delta/LATEST` must update to either:
- Scan `.delta/` directory for run histories directly
- Use explicit `run_id` tracking
- Use `delta list-runs` command

**Automation Scripts**: Scripts using implicit `delta continue` will fail by design. They must update to implement explicit `run_id` tracking:

**v1.9 Script (No Longer Valid)**:
```bash
delta run -m "Task"
delta continue  # Fails in v1.10
```

**v1.10 Script (Required Pattern)**:
```bash
# Pattern A: Engine-generated ID
OUTPUT=$(delta run -m "Task" --format json)
RUN_ID=$(echo "$OUTPUT" | jq -r '.run_id')
delta continue --run-id "$RUN_ID"

# Pattern B: Client-generated ID (Recommended for robustness)
RUN_ID=$(uuidgen)
delta run --run-id "$RUN_ID" -m "Task" --format json
delta continue --run-id "$RUN_ID"
```

**Interactive Usage**: Human developers must use `delta list-runs` to identify runs, or install convenience wrappers (see Section 6.3).

### 9.3 Migration Path

**No Automated Migration Tool**: Given the early adoption stage and minimal user base, we implement these changes immediately without transition period or migration utilities.

**Quick Fix for Existing Workspaces**:
```bash
# Remove LATEST pointer (no other changes needed)
rm .delta/LATEST

# Update scripts to use --run-id (see examples above)
```

**Documentation**:
- Migration mentioned in CLAUDE.md (updated commands section)
- All examples updated to demonstrate v1.10 patterns
- Troubleshooting guide for common migration issues

### 9.4 Benefits Justification

These breaking changes deliver significant improvements across multiple dimensions:

1. **Architectural Robustness**: Eliminates race conditions, enables true concurrency
2. **Engineering Simplicity**: Removes ~200 lines of complex implicit logic
3. **Orchestration Reliability**: Client-generated IDs + Janitor = deterministic recovery
4. **Philosophical Consistency**: Complete adherence to "Explicit over Implicit"
5. **Future-Proof**: Lays foundation for advanced multi-agent orchestration (v2.0)

This positions Delta Engine as a robust, production-ready foundation for concurrent AI system orchestration.

---

## 10. Conclusion

Delta Engine v1.10 represents a fundamental architectural refinement, transitioning from an implicit, single-frontier model to an explicit, frontierless model optimized for concurrent orchestration.

By eliminating shared mutable state (`.delta/LATEST`), enforcing explicit run identification, and providing robust recovery mechanisms (Client-Generated IDs + Janitor), v1.10 achieves true concurrency support while maintaining engineering simplicity.

The strict adherence to Unix I/O principles and explicit output contracts (`RunResult` v2.0) ensures Delta Engine can serve as a reliable building block in complex, automated AI workflows.

This architecture positions Delta Engine to fulfill its core mission: enabling complex intelligence through simple, composable agents—now with the robustness and concurrency guarantees required for production systems.
