# Delta Engine Architecture Design v1.7: Tool Configuration Simplification and Execution Contracts

**Version**: 1.7.0
**Date**: October 11, 2025
**Status**: Final Specification
**Author**: Delta Engine Lead Architect

---

## 1. Overview and Motivation

Delta Engine's core mission is to provide "engineering-effective and simple" tools to accelerate AI Agent prototype development and iteration. However, we have observed that the current tool definition DSL (based on `command` arrays and `parameters` injection rules) is relatively verbose, increasing cognitive load and has become a bottleneck for rapid prototyping.

The core goal of v1.7 is to introduce a set of **Syntax Sugar** for tool configuration, allowing developers to define tools in a more intuitive way that is closer to natural command-line syntax. The essence of this iteration is to elevate the tool's **Execution Context** to a top-level declaration by introducing two clear and mutually exclusive keywords: `exec:` and `shell:`.

**Note:** This is a configuration-level simplification that does not change the underlying Function Calling execution model. All simplified syntax will ultimately be compiled into a standard, secure internal representation.

---

## 2. Core Philosophy and Design Principles

### 2.1 Core Philosophy: Explicit over Implicit

Throughout all exploratory work prior to v1.7, we faced a central dilemma: how to balance conciseness with predictability. Attempting to distinguish between different execution modes through "automatic detection," while seemingly flexible, fundamentally introduces unpredictable **"magic"**.

For an engineering tool aspiring to be a "scientific instrument," predictability is an unshakable foundation. Therefore, v1.7's design strictly adheres to the principle of "explicit over implicit." We no longer require the engine to "guess" the user's intent; instead, we let users clearly **"declare"** the execution environment they need through keywords.

We introduce two mutually exclusive top-level keywords, `exec:` and `shell:`, elevating the execution context decision to an explicit **contract**:

- `exec:` is a contract where users declare: "This command structure is simple and requires no Shell intervention; please execute it safely and directly."
- `shell:` is another contract where users declare: "I need the full power of the Shell (such as pipes, redirections); please execute in a Shell environment and use safe parameterization by default."

This paradigm shift from "detection" to "declaration" completely returns control to the user, making tool behavior 100% transparent and predictable.

### 2.2 Design Principle: Secure by Default

Regardless of which mode is used, simplified syntax must adopt the safest parameter-passing method by default. Only when users explicitly request it (via the `:raw` modifier) should security protections be lifted.

### 2.3 Engineering Goals

- **Lower barriers:** Provide an extremely concise configuration experience for 80% of common scenarios.
- **Maintain security:** Ensure simplified syntax provides the highest level of security by default (preventing command injection).
- **Ensure clarity:** Eliminate "magic" and uncertainty in configuration.
- **Full compatibility:** 100% backward compatible with existing full configuration syntax.
- **Provide transparency:** Provide tools allowing users to see how simplified syntax is expanded.

### 2.4 Non-Goals

- **Replace full configuration:** Complex scenarios (such as conditional logic parameter injection) still require full configuration.
- **Introduce new execution concepts:** Does not change the underlying execution model.
- **Automatic execution mode detection:** The engine does not guess user intent; execution mode must be explicitly declared.

---

## 3. Detailed Specification

### 3.1 Configuration Architecture and Mutual Exclusivity

In the `tools` list of `config.yaml`, new optional fields are introduced to the tool definition object.

```yaml
tools:
  - name: tool_name
    description: "..."

    # --- v1.7 Execution Context (Choose One, Mutually Exclusive) ---
    exec: "command template string"   # Mode 1: Direct Execution (Safe Default)
    # OR
    shell: "shell script template"    # Mode 2: Shell Execution (Powerful Tool)
    # OR
    # command: ["cmd", "arg"]         # Mode 3: Full Configuration (Existing v1.0-v1.6 syntax)

    # --- Common Options ---
    stdin: param_name                 # (Optional) Specify parameter passed via standard input
    parameters: [...]                 # (Optional) Override/supplement parameter definitions
```

**Mutual Exclusivity Rule:** `exec:`, `shell:`, and `command:` (array form) are mutually exclusive within a single tool definition. The engine must validate and ensure only one is used.

### 3.2 Placeholder Syntax

Uniformly adopt `${param_name}` as parameter placeholders.

### 3.3 `exec:` Mode: Direct Execution (The Safe Default)

Used for executing commands with simple structure and no Shell dependencies. Suitable for 80% of scenarios.

```yaml
# Examples
- name: list_files
  exec: "ls -F ${directory}"

- name: run_script_safely
  # Even if script content is malicious code, it will only be passed as a string argument to bash -c
  exec: "bash -c ${script}"
```

**Behavior Definition:**

1. **Direct Execution:** Commands are executed through direct OS process calls (e.g., `execvp`), without Shell interpreter involvement.
2. **Safe Tokenization:** The engine safely splits the template string into command and argument arrays.
3. **Safe Parameter Passing:** All `${param}` values are passed as independent, safe command-line arguments.

**Constraints and Validation:**

- Shell metacharacters (such as `|`, `>`, `<`, `&`, `;`, `&&`, `||`) are **prohibited** in `exec:` templates.
- The engine must validate this during configuration loading; if violations are found, it must report an error and prompt the user to use `shell:`.

#### 3.3.1 Tokenization Algorithm Details

The `exec:` mode uses **shell-like lexical parsing** (e.g., Python's `shlex.split` or equivalent) to parse the template string at configuration load time.

**Key Principles:**

- **Static vs Dynamic Boundary:**
  - **Static parts** (fixed text in template) support quotes for whitespace
  - **Dynamic parts** (`${param}` placeholders) are safely injected as arguments

**Examples:**

```yaml
# ✅ Valid: Quoted static argument
- name: search_pattern
  exec: 'grep "fixed pattern" ${file}'
  # Tokenizes to: ["grep", "fixed pattern", "${file}"]
  # After injection: ["grep", "fixed pattern", "actual_file.txt"]

# ✅ Valid: Multiple placeholders
- name: list_dirs
  exec: "ls -la ${dir1} ${dir2}"
  # Tokenizes to: ["ls", "-la", "${dir1}", "${dir2}"]

# ❌ Invalid: Shell metacharacters
- name: count_lines
  exec: "cat ${file} | wc -l"
  # Rejected at validation: Pipe operator not allowed in exec: mode
```

**Implementation Requirements:**

- Use POSIX-compliant shell tokenization library (e.g., Go's `shlex`, Node.js `shell-quote`, Python `shlex`)
- Preserve quotes in static arguments
- Reject tokens containing shell metacharacters (`|`, `>`, `<`, `&`, `;`, `&&`, `||`, `` ` ``, `$()`, `${}`)
- Support escaped quotes within static strings

### 3.4 `shell:` Mode: Shell Interpreted Execution (The Powerful Tool)

Used for scenarios requiring advanced Shell features like pipes, redirections, and command chains.

```yaml
# Example
- name: count_matches
  shell: "grep ${pattern} ${file} | wc -l"
```

**Behavior Definition:**

1. **Shell Wrapping:** The engine automatically wraps the entire template string with `sh -c "..."` for execution.
2. **Default Safe Parameterization (Key Design):** To prevent command injection, the engine must automatically replace all `${param}` with **quoted** positional parameters (`"$1"`, `"$2"`, ...) and safely pass actual values through `sh -c`'s parameter list.
    - *For example: `grep "$1" "$2" | wc -l`.*

### 3.5 Expert Escape Hatch: `:raw` Injection (Shell-only)

To meet expert users' needs for Shell-native parameter expansion (e.g., passing a string of flags), introduce the `:raw` modifier.

```yaml
# Example: options value might be "-d -p 80:80", requiring Shell parsing
- name: run_docker
  shell: "docker run ${options:raw} ${image}"
```

**Behavior Definition:**

1. The `:raw` modifier is **only valid in `shell:` mode**. Using it in `exec:` mode should report an error.
2. Parameters marked as `:raw` are replaced with positional parameters **without quotes** when substituted (`$1` rather than `"$1"`).
    - *For example: `docker run $1 "$2"`.*

**Security Declaration:** Using `:raw` is an explicit action, indicating that the user understands and accepts potential command injection risks.

### 3.6 `stdin` Handling

Adopt a unified external `stdin:` keyword to declare parameters passed through standard input. This is valid for both `exec:` and `shell:` modes.

```yaml
- name: write_file
  exec: "tee ${filename}"
  stdin: content  # The parameter named 'content' is passed via stdin
```

### 3.7 Hybrid Mode and Parameter Override

Users can provide a `parameters` block while using `exec:` or `shell:` to override or supplement auto-inferred parameter definitions (e.g., adding descriptions, type constraints, or default values). Explicit configuration always takes precedence over auto-inference.

```yaml
- name: search
  exec: "grep ${pattern} ${file}"
  parameters:
    - name: file
      description: "The file to search within."
      default: "./data.txt"
```

#### 3.7.1 Parameter Merging Algorithm

When both template placeholders and explicit `parameters` block exist, the engine follows this three-step algorithm:

**Step 1: Inference**

Extract all `${param}` or `${param:raw}` placeholders from the template and infer metadata for each:

- `name`: Extracted from placeholder (e.g., `${file}` → `file`)
- `type`: Default to `"string"` (MVP only supports string type)
- `inject_as`: Inferred based on context:
  - `exec:` mode → `"argument"`
  - `shell:` mode → `"argument"` (passed via `sh -c` positional params)
  - External `stdin:` keyword → `"stdin"` (overrides inferred mode)
- `position`: Sequential order in template (0-indexed)
- `:raw` modifier: Captured if present (shell: only)

**Step 2: Merge and Override**

For each parameter in the explicit `parameters` block:

- If parameter name exists in inferred set:
  - **Override**: `description`, `default`, custom metadata
  - **Preserve**: `inject_as`, `position`, `:raw` modifier (inferred values)
- If parameter name doesn't exist in inferred set:
  - **Error**: Undefined parameter (not found in template)

**Step 3: Consistency Validation**

Validate merged parameter list:

- ✅ **Injection mode immutability**: Explicit `parameters` cannot change `inject_as`
- ✅ **Position immutability**: Explicit `parameters` cannot change `position`
- ✅ **:raw consistency**: Explicit parameters cannot add/remove `:raw` modifier
- ✅ **stdin uniqueness**: At most one parameter with `inject_as: stdin`
- ✅ **Type consistency**: Explicit type must match inferred type (currently always `string`)

**Examples:**

```yaml
# ✅ Valid: Add descriptions to inferred parameters
- name: search_tool
  exec: "grep ${pattern} ${file}"
  parameters:
    - name: file
      description: "File to search in"
      default: "./data.txt"
    - name: pattern
      description: "Search pattern (regex supported)"
# Result: Both parameters get descriptions, file gets default value

# ✅ Valid: External stdin declaration
- name: write_tool
  exec: "tee ${filename}"
  stdin: content  # 'content' parameter inferred with inject_as: stdin
  parameters:
    - name: content
      description: "Content to write"
# Result: 'content' parameter has inject_as: stdin (from external keyword)

# ❌ Invalid: Conflicting injection mode
- name: bad_tool
  shell: "cat ${file} | wc -l"
  parameters:
    - name: file
      inject_as: stdin  # ❌ ERROR: Cannot override inferred inject_as: argument
# Error message: "Cannot override inject_as for parameter 'file' (inferred: argument, explicit: stdin)"

# ❌ Invalid: Undefined parameter
- name: bad_tool2
  exec: "echo ${message}"
  parameters:
    - name: unknown_param  # ❌ ERROR: Not found in template
      description: "This parameter doesn't exist"
# Error message: "Parameter 'unknown_param' not found in template"

# ❌ Invalid: Trying to add :raw via explicit parameters
- name: bad_tool3
  shell: "docker run ${flags} ${image}"
  parameters:
    - name: flags
      raw: true  # ❌ ERROR: :raw must be declared in template
# Error message: ":raw modifier must be specified in template syntax (${flags:raw})"
```

**Implementation Note:**

The merging algorithm ensures that the **structural contract** (how parameters are injected) is determined by the template syntax, while the **semantic metadata** (descriptions, defaults) can be enriched via explicit configuration. This maintains the transparency and predictability of the simplified syntax while preserving flexibility.

### 3.8 Boundary Cases Handling

This section defines behavior for edge cases and special scenarios.

#### 3.8.1 Multi-line Commands

`shell:` mode fully supports YAML multi-line string syntax:

```yaml
# Using literal block scalar (|)
- name: multi_line_script
  shell: |
    export VAR=${value}
    echo "Processing..."
    ./script.sh "$VAR"

# Using folded block scalar (>)
- name: long_command
  shell: >
    docker run --rm
    -v ${volume}:/data
    ${image}
```

**Behavior:**
- The entire multi-line script is treated as a single unit
- Passed to `sh -c` as a single script string
- Parameters are substituted with positional parameters (`$1`, `$2`, etc.)
- Each line executes sequentially in the same shell session

#### 3.8.2 Empty Parameter Values

If the LLM provides an empty string (`""`) as a parameter value:

- The parameter is passed as an empty string argument to the command
- It occupies a position in the argument array
- Behavior is identical to POSIX shell argument handling

**Examples:**

```yaml
# exec: mode
- name: list_directory
  exec: "ls ${directory}"
  # If directory = "", executes: ls ""
  # Result: Attempts to list file named "" (likely: "No such file or directory")

# shell: mode
- name: search_pattern
  shell: "grep ${pattern} ${file}"
  # If pattern = "", executes: grep "" "data.txt"
  # Result: Matches every line (empty pattern matches all)
```

**Recommendation:** Tools should validate parameter values in `pre_tool_exec` hooks if empty strings are problematic.

#### 3.8.3 Special Characters in Parameter Values

Due to the safe parameter passing mechanism (see Section 4.2.1):

- Parameter values are treated as **literal strings**
- Special characters (`;`, `|`, `$`, `` ` ``, `\`, `"`, `'`) are **NOT interpreted** by the shell
- Quotes within parameter values are preserved as literal characters

**Examples:**

```yaml
# Example 1: Semicolon (command separator)
- name: echo_test
  shell: "echo ${message}"
  # If message = "; rm -rf /tmp/test", executes: echo "; rm -rf /tmp/test"
  # Result: Outputs "; rm -rf /tmp/test" (literal, does not execute rm)

# Example 2: Variable expansion syntax
- name: path_test
  exec: "echo ${path}"
  # If path = "${HOME}/test", executes: echo "${HOME}/test"
  # Result: Outputs "${HOME}/test" (literal, not expanded)

# Example 3: Command substitution syntax
- name: command_test
  shell: "echo ${input}"
  # If input = "$(whoami)", executes: echo "$(whoami)"
  # Result: Outputs "$(whoami)" (literal, not executed)

# Example 4: Nested quotes
- name: quote_test
  shell: "grep ${pattern} ${file}"
  # If pattern = '"test"', executes: grep '"test"' 'data.txt'
  # Result: Searches for literal string "test" (including quotes)
```

**Security Note:** This behavior is the foundation of `shell:` mode's default safety.

#### 3.8.4 Parameter Values Containing Placeholder Syntax

If a parameter value contains the string `${`:

- It is treated as literal text (no recursive substitution)
- No conflict with template placeholder syntax
- No escaping required

**Example:**

```yaml
- name: echo_message
  exec: "echo ${msg}"
  # If msg = "Value is ${VARIABLE}", executes: echo "Value is ${VARIABLE}"
  # Result: Outputs "Value is ${VARIABLE}" (literal)
```

**Rationale:** Placeholders are resolved at configuration load time (template → internal representation). Parameter values are provided at runtime and never undergo template parsing.

#### 3.8.5 Whitespace in Parameter Values

Whitespace (spaces, tabs, newlines) in parameter values is preserved:

```yaml
# Example: Multi-line content
- name: write_content
  exec: "tee ${filename}"
  stdin: content
  # If content = "line1\nline2\nline3", all three lines are written
  # Result: File contains three lines with exact whitespace

# Example: Leading/trailing spaces
- name: echo_spaced
  exec: "echo ${text}"
  # If text = "  hello  ", executes: echo "  hello  "
  # Result: Outputs "  hello  " (with spaces preserved)
```

### 3.9 Anti-patterns and Common Mistakes

This section illustrates **incorrect** configurations and their correct alternatives to help users avoid common pitfalls.

#### ❌ Anti-pattern 1: Using Pipes in exec: Mode

```yaml
# ❌ WRONG: Pipe operator in exec:
- name: count_lines
  exec: "cat ${file} | wc -l"
  # Error at config load: Shell metacharacter '|' not allowed in exec: mode
  # Hint: Use shell: mode for pipes, or split into separate tools

# ✅ CORRECT: Use shell: mode
- name: count_lines
  shell: "cat ${file} | wc -l"

# ✅ ALTERNATIVE: Use native tool without pipe
- name: count_lines
  exec: "wc -l ${file}"
```

#### ❌ Anti-pattern 2: Using :raw in exec: Mode

```yaml
# ❌ WRONG: :raw modifier in exec:
- name: echo_flags
  exec: "echo ${flags:raw}"
  # Error at config load: :raw modifier only allowed in shell: mode

# ✅ CORRECT: Switch to shell: mode
- name: echo_flags
  shell: "echo ${flags:raw}"
```

#### ❌ Anti-pattern 3: Trying to Override Injection Mode

```yaml
# ❌ WRONG: Conflicting injection specification
- name: search_tool
  shell: "grep ${pattern} ${file}"
  parameters:
    - name: pattern
      inject_as: stdin  # Error: Cannot change inferred inject_as
  # Error message: "Cannot override inject_as for parameter 'pattern'"

# ✅ CORRECT: Use external stdin: keyword
- name: search_tool
  shell: "grep -f - ${file}"
  stdin: pattern  # Declares 'pattern' as stdin parameter
```

#### ❌ Anti-pattern 4: Mixing Execution Contexts

```yaml
# ❌ WRONG: Multiple execution modes
- name: bad_tool
  exec: "echo ${msg}"
  shell: "cat ${file}"
  # Error: exec:, shell:, and command: are mutually exclusive

# ✅ CORRECT: Choose one mode
- name: good_tool
  exec: "echo ${msg}"
```

#### ❌ Anti-pattern 5: Shell Redirection Syntax in exec:

```yaml
# ❌ WRONG: Redirection in exec:
- name: write_log
  exec: "echo ${msg} > ${logfile}"
  # Error: '>' is a shell metacharacter

# ✅ CORRECT Option 1: Use shell: mode
- name: write_log
  shell: "echo ${msg} > ${logfile}"

# ✅ CORRECT Option 2: Use stdin: and redirection-capable tool
- name: write_log
  exec: "tee ${logfile}"
  stdin: msg
```

#### ❌ Anti-pattern 6: Forgetting to Declare stdin Parameter

```yaml
# ❌ WRONG: stdin parameter not declared but used in tool
- name: write_file
  exec: "tee ${filename}"
  # If LLM tries to pass 'content' parameter, it will be passed as argument
  # Result: tee "./output.txt" "file content here" (incorrect)

# ✅ CORRECT: Explicitly declare stdin parameter
- name: write_file
  exec: "tee ${filename}"
  stdin: content  # Now 'content' is passed via stdin
```

#### ❌ Anti-pattern 7: Assuming Shell Variable Expansion Works

```yaml
# ❌ WRONG EXPECTATION: Expecting ${HOME} to expand
- name: bad_path
  exec: "ls ${directory}"
  # If directory = "${HOME}/test", this WILL NOT expand ${HOME}
  # Result: Tries to list directory literally named "${HOME}/test"

# ✅ CORRECT: Pass expanded paths from environment
# Solution 1: Use $AGENT_HOME or $CWD (Delta Engine variables)
- name: list_agent_files
  exec: "ls ${AGENT_HOME}/config"

# Solution 2: Have the LLM expand paths before calling tool
# (LLM should resolve environment context and pass absolute paths)
```

#### ❌ Anti-pattern 8: Using Glob Patterns Without shell:

```yaml
# ❌ WRONG: Glob pattern in exec: mode
- name: list_all_logs
  exec: "ls ${pattern}"
  # If pattern = "*.log", this will look for file literally named "*.log"
  # Result: No such file or directory (glob NOT expanded)

# ✅ CORRECT: Use shell: mode for glob expansion
- name: list_all_logs
  shell: "ls ${pattern:raw}"
  # With pattern = "*.log", the shell expands the glob
  # Note: Use :raw so "*.log" is not quoted (quotes prevent glob expansion)
```

#### ⚠️ Warning Pattern: Over-using :raw

```yaml
# ⚠️ RISKY: Using :raw when not necessary
- name: risky_tool
  shell: "grep ${pattern:raw} ${file}"
  # If pattern comes from untrusted LLM output, this is vulnerable
  # A malicious pattern like ". /etc/passwd ; #" could inject commands

# ✅ SAFER: Only use :raw when truly needed (e.g., flag lists)
- name: safer_tool
  shell: "grep ${pattern} ${file}"
  # Default quoting protects against injection
```

**Best Practices:**

1. **Prefer `exec:` for simple commands** - It's the safest default
2. **Use `shell:` only when you need pipes/redirects** - More power = more risk
3. **Avoid `:raw` unless absolutely necessary** - Quote by default
4. **Use `delta tool expand`** - Verify how your config is interpreted
5. **Test with malicious inputs** - Try pattern = `"; rm -rf /tmp/test"` in dev

---

## 4. Internal Representation and Expansion Rules

This section defines how syntax sugar is deterministically expanded into Delta Engine's internal full configuration format (i.e., the standard format from v1.0-v1.6). This is key to engineering implementation.

### 4.1 `exec:` Mode Expansion

```yaml
# Input (v1.7 simplified syntax)
- name: run_script
  exec: "bash -c ${script}"

# Output (Engine internal full representation)
- name: run_script
  command: ["bash", "-c"]  # Fixed portion parsed out
  parameters:
    - name: script
      type: string
      inject_as: argument
      # Key: Parameter appended after command array
      position: 0
```

### 4.2 `shell:` Mode Expansion (Default Safe)

```yaml
# Input (v1.7 simplified syntax)
- name: count_matches
  shell: "grep ${pattern} ${file} | wc -l"

# Output (Engine internal full representation)
- name: count_matches
  # Key: Automatically generate quoted positional parameter template
  command: ["sh", "-c", "grep \"$1\" \"$2\" | wc -l", "--"]
  parameters:
    - name: pattern
      type: string
      inject_as: argument
      # Key: Parameters passed through sh -c's parameter list, corresponding to positional parameters
      position: 0  # Corresponds to $1
    - name: file
      type: string
      inject_as: argument
      position: 1  # Corresponds to $2
```

#### 4.2.1 Safety Mechanism: How `sh -c --` Prevents Injection

The default safety of `shell:` mode relies on the **POSIX standard mechanism** of `sh -c "script" -- arg1 arg2`.

**Mechanism Breakdown:**

1. **Argument Separation:**
   - The script string (`"grep \"$1\" \"$2\" | wc -l"`) is passed as the 3rd argument to `sh`
   - Parameter values (`pattern`, `file`) are passed as **separate arguments** after `--`
   - **No text concatenation or interpolation** occurs between script and parameters

2. **System Call Example:**

```c
// Actual system call (pseudocode)
execvp("sh", [
  "sh",                              // argv[0]: shell executable
  "-c",                              // argv[1]: execute following string
  "grep \"$1\" \"$2\" | wc -l",     // argv[2]: script (immutable)
  "--",                              // argv[3]: options terminator
  "\" ; rm -rf / ; \"",             // argv[4]: value for $1 (via argv, safe)
  "data.txt"                         // argv[5]: value for $2 (via argv, safe)
]);
```

3. **Shell Processing:**
   - The shell assigns `argv[4]` to variable `$1` and `argv[5]` to `$2`
   - When executing `grep "$1"`, the quotes ensure `$1`'s **entire content** is treated as a **single literal string** argument
   - Even if `$1` contains quotes, semicolons, or other metacharacters, they are **NOT interpreted** as shell syntax

4. **Concrete Attack Scenario (Prevented):**

```yaml
shell: "grep ${pattern} ${file} | wc -l"
# Attacker sets pattern = "\" ; rm -rf /tmp/test ; \""

# Actual execution:
# sh -c 'grep "$1" "$2" | wc -l' -- '" ; rm -rf /tmp/test ; "' 'data.txt'

# This resolves to:
# grep '" ; rm -rf /tmp/test ; "' 'data.txt' | wc -l

# Result: SAFE
# - grep searches for literal string '" ; rm -rf /tmp/test ; "' in data.txt
# - No command injection occurs
# - /tmp/test is NOT deleted
```

5. **Why This Is Secure:**

- ✅ **No text substitution**: Parameters never undergo string interpolation into the script
- ✅ **Argv-based passing**: Parameters are passed through the OS kernel's argv array, isolated from the script string
- ✅ **Quote protection**: The `"$1"` syntax in the script treats the entire parameter value as an atomic string
- ✅ **Option terminator**: The `--` ensures no parameter is misinterpreted as a shell option
- ✅ **POSIX standard**: This is the same mechanism used by secure tools like `find -exec {} +`

**Security Guarantee:**

As long as the script template contains quoted positional parameters (`"$1"`, `"$2"`, etc.), parameter values are **guaranteed** to be treated as literal strings, regardless of their content. This is enforced by the POSIX shell specification and the OS kernel's process execution model.

**Implementation Requirements:**

- ✅ Engines **MUST** use `execvp()` or equivalent low-level process APIs
- ❌ Engines **MUST NOT** use `system()` or string-based shell invocation
- ✅ Engines **MUST** preserve the argument array structure
- ✅ Engines **MUST** include the `--` terminator in the command array

**References:**

- POSIX.1-2017 Shell Command Language: [https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html)
- Shell parameter expansion: Section 2.6.2
- Special parameter `$1`-`$9`: Section 2.5.1

### 4.3 `shell:` Mode Expansion (`:raw` Modifier)

```yaml
# Input (v1.7 simplified syntax)
- name: run_docker
  shell: "docker run ${options:raw} ${image}"

# Output (Engine internal full representation)
- name: run_docker
  # Key: $1 has no quotes (corresponding to :raw), $2 has quotes
  command: ["sh", "-c", "docker run $1 \"$2\"", "--"]
  parameters:
    - name: options
      type: string
      inject_as: argument
      position: 0
    - name: image
      type: string
      inject_as: argument
      position: 1
```

---

## 5. Implementation Architecture and Validation

Simplified syntax processing will be completed during the engine's configuration loading and parsing phase.

### 5.1 Parser Module (ToolExpander)

A new `ToolExpander` module (or service class) is required. Its responsibility is to traverse all tool definitions in `config.yaml`, identify tools using simplified syntax, and convert them to the internal full representation (as described in Section 4).

### 5.2 Validation Logic

`ToolExpander` must include strict validation logic to ensure configuration correctness and security. The following checks must be implemented:

1. **Mutual Exclusivity Validation:** Ensure only one of `exec`, `shell`, `command` (array form) is used in a tool definition.
2. **`exec:` Security Validation:** Scan the `exec:` template string to ensure it does not contain Shell metacharacters (`|`, `>`, `<`, `&`, `;`, `&&`, `||`, etc.). If found, must report an error and prompt the user to use `shell:`.
3. **`:raw` Scope Validation:** Ensure the `:raw` modifier is only used in `shell:` mode. If found in `exec:` mode, must report an error.
4. **Placeholder Parsing Validation:** Ensure all placeholders can be correctly parsed and parameter names comply with specifications.
5. **Parameter Consistency Validation:** Ensure auto-inferred parameters have no conflicts with the `parameters` block (if present) or `stdin` declaration.

---

## 6. Transparency and Tool Ecosystem

A mature solution must be understandable and debuggable. To maintain Delta Engine's transparency principle and unveil the "magic" of syntax sugar, new CLI tools must be introduced.

### 6.1 `delta tool expand` Command

New command: `delta tool expand <path/to/config.yaml>`.

- **Function:** Read a `config.yaml` containing simplified syntax and output the expanded, equivalent full configuration YAML to standard output.
- **Purpose:** Allow users to precisely understand how the engine interprets their configuration. This is a key tool for learning, debugging, and validating configurations, making all syntax sugar behavior completely transparent and predictable.

---

## 7. Compatibility and Migration

This specification is **fully backward compatible**. Existing `config.yaml` files using `command:` (array) and `parameters:` blocks will continue to work normally without any modifications. v1.7 is a purely additive change.

---

## 8. Security Considerations

This design places security first:

1. **`exec:` Security:** By prohibiting Shell metacharacters and enforcing safe tokenization, `exec:` mode provides the highest level of security, fundamentally eliminating command injection risks.
2. **`shell:` Default Security:** Automatic quote parameterization (`"$1"`) makes `shell:` mode safe by default, effectively preventing injection even when handling complex Shell logic.
3. **Explicit Risk Assumption:** The only place that may introduce risk is the `:raw` marker. But it is strictly limited to `shell:` mode and requires explicit user declaration, clearly delineating the boundary of security responsibility.

---

## 9. Conclusion

The v1.7 `exec:` vs `shell:` proposal is a profound embodiment of Delta Engine's core mission: "to provide experts with efficient, transparent, and controllable tools."

By introducing two orthogonal top-level keywords, it elegantly decouples two fundamentally different execution requirements. It eliminates implicit "magic," provides 100% predictable behavior, and while greatly enhancing usability, maintains engineering rigor and security. This design will significantly accelerate the Agent prototype development process, perfectly aligning with Delta Engine's core vision.

---

## 10. Implementation Verification Tests

To ensure the safety mechanisms and expansion rules are correctly implemented, engines **MUST pass** the following test suite before claiming v1.7 compliance.

### Test Suite 1: Command Injection Prevention (exec: mode)

**Test 1.1: Reject Shell Metacharacters**

```yaml
# config.yaml
- name: test_exec_reject_pipe
  exec: "cat ${file} | wc -l"

# Expected Result: Configuration validation error at load time
# Error Message: "Shell metacharacter '|' not allowed in exec: mode. Use shell: mode or remove pipe."
```

**Test 1.2: Reject Redirection**

```yaml
- name: test_exec_reject_redirect
  exec: "echo ${msg} > ${file}"

# Expected Result: Configuration validation error
# Error Message: "Shell metacharacter '>' not allowed in exec: mode."
```

**Test 1.3: Accept Safe Commands**

```yaml
- name: test_exec_safe
  exec: "echo ${message}"

# Expected Result: Configuration loads successfully
# Execution test: message = "; rm -rf /tmp/test_marker"
# Result: echo outputs "; rm -rf /tmp/test_marker" literally
# Verification: /tmp/test_marker file is NOT deleted
```

---

### Test Suite 2: Command Injection Prevention (shell: mode)

**Test 2.1: Semicolon Injection Prevention**

```yaml
- name: test_shell_semicolon
  shell: "echo ${input}"

# Execution test:
# Parameter: input = "; rm -rf /tmp/delta_test_marker; echo done"
# Expected output: "; rm -rf /tmp/delta_test_marker; echo done"
# Verification: File /tmp/delta_test_marker is NOT deleted
# Verification: Exit code = 0 (success)
```

**Test 2.2: Nested Quote Handling**

```yaml
- name: test_shell_quotes
  shell: "grep ${pattern} ${file}"

# Execution test:
# Parameters: pattern = '"test"', file = "sample.txt"
# Expected behavior: grep searches for literal string "test" (including quotes)
# Verification: If sample.txt contains '"test"', grep exits with code 0
# Verification: If sample.txt doesn't contain '"test"', grep exits with code 1
```

**Test 2.3: Command Substitution Prevention**

```yaml
- name: test_shell_command_sub
  shell: "echo ${input}"

# Execution test:
# Parameter: input = "$(whoami)"
# Expected output: "$(whoami)" (literal string)
# Verification: Output is NOT the current username
```

**Test 2.4: Pipe Character in Parameter**

```yaml
- name: test_shell_pipe_in_param
  shell: "echo ${input}"

# Execution test:
# Parameter: input = "test | grep x"
# Expected output: "test | grep x" (literal string, no pipe execution)
# Verification: grep command is NOT executed
```

---

### Test Suite 3: :raw Modifier Behavior

**Test 3.1: :raw Allows Unquoted Expansion**

```yaml
- name: test_raw_flags
  shell: "echo ${flags:raw}"

# Execution test:
# Parameter: flags = "-n -e"
# Expected behavior: echo receives two separate flags (-n and -e)
# Verification: Output has NO trailing newline (due to -n flag)
# Verification: If flags = "-e \nhello", output interprets escape sequences
```

**Test 3.2: :raw Rejection in exec: Mode**

```yaml
- name: test_raw_reject_in_exec
  exec: "echo ${flags:raw}"

# Expected Result: Configuration validation error
# Error Message: ":raw modifier is only allowed in shell: mode"
```

**Test 3.3: :raw with Malicious Input (Security Warning)**

```yaml
- name: test_raw_vulnerability
  shell: "echo ${input:raw}"

# Execution test (demonstrates vulnerability):
# Parameter: input = "; rm -rf /tmp/delta_test_raw_vuln"
# Expected behavior: Command injection OCCURS (this is intentional :raw behavior)
# Verification: File /tmp/delta_test_raw_vuln IS deleted (vulnerability confirmed)
# Documentation: This test confirms :raw bypasses safety, as documented
```

---

### Test Suite 4: Tokenization and Whitespace (exec: mode)

**Test 4.1: Quoted Static Arguments**

```yaml
- name: test_exec_quoted_static
  exec: 'grep "fixed pattern" ${file}'

# Execution test:
# Parameter: file = "test.txt" (containing "fixed pattern with")
# Expected behavior: grep searches for "fixed pattern" (with space) in test.txt
# Verification: Matches lines containing "fixed pattern"
```

**Test 4.2: Multiple Placeholders**

```yaml
- name: test_exec_multi_params
  exec: "echo ${arg1} ${arg2} ${arg3}"

# Execution test:
# Parameters: arg1 = "first", arg2 = "second", arg3 = "third"
# Expected output: "first second third"
# Verification: Three separate arguments passed to echo
```

---

### Test Suite 5: stdin Handling

**Test 5.1: stdin Parameter in exec: Mode**

```yaml
- name: test_stdin_exec
  exec: "wc -l"
  stdin: content

# Execution test:
# Parameter: content = "line1\nline2\nline3"
# Expected output: "3"
# Verification: wc counts lines from stdin
```

**Test 5.2: stdin Parameter in shell: Mode**

```yaml
- name: test_stdin_shell
  shell: "grep ${pattern}"
  stdin: content

# Execution test:
# Parameters: pattern = "test", content = "test1\nfoo\ntest2"
# Expected output: "test1\ntest2"
# Verification: grep reads from stdin, not from pattern parameter
```

---

### Test Suite 6: Multi-line Scripts (shell: mode)

**Test 6.1: Multi-line Script with Parameters**

```yaml
- name: test_multiline
  shell: |
    echo "Start"
    echo ${value}
    echo "End"

# Execution test:
# Parameter: value = "test ; echo injected"
# Expected output:
#   Start
#   test ; echo injected
#   End
# Verification: "injected" appears exactly once (as literal, not executed)
```

**Test 6.2: Multi-line with Pipes**

```yaml
- name: test_multiline_pipes
  shell: |
    echo ${text} |
    tr '[:lower:]' '[:upper:]' |
    wc -c

# Execution test:
# Parameter: text = "hello"
# Expected output: "6" (5 chars + newline)
# Verification: Pipes work correctly across lines
```

---

### Test Suite 7: Parameter Merging and Validation

**Test 7.1: Valid Parameter Override**

```yaml
- name: test_param_merge
  exec: "echo ${msg}"
  parameters:
    - name: msg
      description: "Message to print"
      default: "hello"

# Expected Result: Configuration loads successfully
# Execution test (no parameter): Uses default "hello"
# Execution test (with parameter): Uses provided value
```

**Test 7.2: Invalid Parameter Override (injection mode conflict)**

```yaml
- name: test_param_conflict
  shell: "grep ${pattern} ${file}"
  parameters:
    - name: pattern
      inject_as: stdin

# Expected Result: Configuration validation error
# Error Message: "Cannot override inject_as for parameter 'pattern' (inferred: argument, explicit: stdin)"
```

**Test 7.3: Undefined Parameter**

```yaml
- name: test_undefined_param
  exec: "echo ${msg}"
  parameters:
    - name: undefined_param
      description: "This param doesn't exist in template"

# Expected Result: Configuration validation error
# Error Message: "Parameter 'undefined_param' not found in template"
```

---

### Passing Criteria

An implementation is **v1.7 compliant** if and only if:

✅ **Test Suite 1**: All 3 tests pass (exec: mode security)
✅ **Test Suite 2**: All 4 tests pass (shell: mode security)
✅ **Test Suite 3**: All 3 tests pass (:raw behavior)
✅ **Test Suite 4**: All 2 tests pass (tokenization)
✅ **Test Suite 5**: All 2 tests pass (stdin handling)
✅ **Test Suite 6**: All 2 tests pass (multi-line support)
✅ **Test Suite 7**: All 3 tests pass (parameter merging)

**Total**: 19/19 tests must pass

**Security Validation:**

The following security properties must be demonstrated:

1. **No command injection** in exec: mode (Suite 1)
2. **No command injection** in shell: mode default (Suite 2)
3. **Correct vulnerability** in :raw mode (Suite 3.3 - intentional)
4. **Safe tokenization** preserves whitespace (Suite 4)
5. **Correct argv-based** parameter passing (all suites)

**Implementation Notes:**

- Tests should be automated (e.g., in CI/CD pipeline)
- Failed tests must block v1.7 feature release
- Each test should create/cleanup temporary files in isolated directories
- Security tests (command injection) should verify filesystem state, not just output
